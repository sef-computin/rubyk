// Code generated from RubyK.g4 by ANTLR 4.10. DO NOT EDIT.

package parser // RubyK

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type RubyKParser struct {
	*antlr.BaseParser
}

var rubykParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func rubykParserInit() {
	staticData := &rubykParserStaticData
	staticData.literalNames = []string{
		"", "", "','", "';'", "", "'end'", "'def'", "'return'", "'pir'", "'if'",
		"'else'", "'elsif'", "'unless'", "'while'", "'retry'", "'break'", "'for'",
		"'true'", "'false'", "'+'", "'-'", "'*'", "'/'", "'%'", "'**'", "'=='",
		"'!='", "'>'", "'<'", "'<='", "'>='", "'='", "'+='", "'-='", "'*='",
		"'/='", "'%='", "'**='", "'&'", "'|'", "'^'", "'~'", "'<<'", "'>>'",
		"", "", "", "'('", "')'", "'['", "']'", "'nil'",
	}
	staticData.symbolicNames = []string{
		"", "LITERAL", "COMMA", "SEMICOLON", "CRLF", "END", "DEF", "RETURN",
		"PIR", "IF", "ELSE", "ELSIF", "UNLESS", "WHILE", "RETRY", "BREAK", "FOR",
		"TRUE", "FALSE", "PLUS", "MINUS", "MUL", "DIV", "MOD", "EXP", "EQUAL",
		"NOT_EQUAL", "GREATER", "LESS", "LESS_EQUAL", "GREATER_EQUAL", "ASSIGN",
		"PLUS_ASSIGN", "MINUS_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN",
		"EXP_ASSIGN", "BIT_AND", "BIT_OR", "BIT_XOR", "BIT_NOT", "BIT_SHL",
		"BIT_SHR", "AND", "OR", "NOT", "LEFT_RBRACKET", "RIGHT_RBRACKET", "LEFT_SBRACKET",
		"RIGHT_SBRACKET", "NIL", "SL_COMMENT", "ML_COMMENT", "WS", "INT", "FLOAT",
		"ID", "ID_GLOBAL", "ID_FUNCTION",
	}
	staticData.ruleNames = []string{
		"program", "expression_list", "expression", "global_get", "global_set",
		"global_result", "function_inline_call", "function_definition", "function_definition_body",
		"function_definition_header", "function_name", "function_definition_params",
		"function_definition_params_list", "function_definition_param_id", "return_statement",
		"function_call", "function_call_param_list", "function_call_params",
		"function_param", "function_unnamed_param", "function_named_param",
		"function_call_assignment", "all_result", "elsif_statement", "if_elsif_statement",
		"if_statement", "unless_statement", "while_statement", "for_statement",
		"init_expression", "all_assignment", "for_init_list", "cond_expression",
		"loop_expression", "for_loop_list", "statement_body", "statement_expression_list",
		"assignment", "dynamic_assignment", "int_assignment", "float_assignment",
		"string_assignment", "initial_array_assignment", "array_assignment",
		"array_definition", "array_definition_elements", "array_selector", "dynamic_result",
		"dynamic_", "int_result", "float_result", "string_result", "comparison_list",
		"comparison", "comp_var", "lvalue", "rvalue", "break_expression", "literal_t",
		"float_t", "int_t", "bool_t", "nil_t", "id_", "id_global", "id_function",
		"terminator", "else_token", "crlf",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 59, 807, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 147, 8, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 153, 8, 1, 10, 1, 12, 1, 156, 9, 1, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 166, 8, 2, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7,
		1, 7, 1, 7, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 3, 9, 195, 8, 9, 1, 10, 1, 10, 3, 10, 199, 8, 10, 1, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 208, 8, 11, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 5, 12, 216, 8, 12, 10, 12, 12, 12, 219, 9, 12, 1,
		13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 238, 8, 15, 1, 16, 1,
		16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 5, 17, 248, 8, 17, 10, 17,
		12, 17, 251, 9, 17, 1, 18, 1, 18, 3, 18, 255, 8, 18, 1, 19, 1, 19, 1, 19,
		1, 19, 3, 19, 261, 8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3,
		20, 269, 8, 20, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22,
		278, 8, 22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1,
		24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24,
		1, 24, 1, 24, 3, 24, 301, 8, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1,
		25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25,
		1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 325, 8, 25, 1, 26, 1,
		26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26,
		1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3,
		26, 349, 8, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28,
		379, 8, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 387, 8, 30,
		1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 395, 8, 31, 10, 31, 12,
		31, 398, 9, 31, 1, 32, 1, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34,
		1, 34, 1, 34, 5, 34, 410, 8, 34, 10, 34, 12, 34, 413, 9, 34, 1, 35, 1,
		35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36,
		426, 8, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1,
		36, 1, 36, 1, 36, 5, 36, 439, 8, 36, 10, 36, 12, 36, 442, 9, 36, 1, 37,
		1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 452, 8, 37, 1,
		38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 462, 8, 38,
		1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 472, 8,
		39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 482,
		8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 492,
		8, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		44, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 3, 45, 510, 8, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 3, 45, 516, 8, 45, 5, 45, 518, 8, 45, 10, 45, 12,
		45, 521, 9, 45, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 527, 8, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 535, 8, 46, 1, 46, 1, 46, 3, 46,
		539, 8, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1,
		47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 567, 8, 47, 1,
		47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 5,
		47, 590, 8, 47, 10, 47, 12, 47, 593, 9, 47, 1, 48, 1, 48, 1, 48, 3, 48,
		598, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 606, 8, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 614, 8, 49, 10, 49, 12,
		49, 617, 9, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 633, 8, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50,
		5, 50, 647, 8, 50, 10, 50, 12, 50, 650, 9, 50, 1, 51, 1, 51, 1, 51, 1,
		51, 1, 51, 1, 51, 3, 51, 658, 8, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51,
		1, 51, 5, 51, 666, 8, 51, 10, 51, 12, 51, 669, 9, 51, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 692, 8,
		52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 702,
		8, 53, 1, 54, 1, 54, 1, 54, 3, 54, 707, 8, 54, 1, 55, 1, 55, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 3, 56, 737, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 5, 56, 766, 8, 56, 10, 56, 12, 56, 769, 9, 56, 1, 57, 1,
		57, 1, 58, 1, 58, 1, 59, 1, 59, 1, 60, 1, 60, 1, 61, 1, 61, 1, 62, 1, 62,
		1, 63, 1, 63, 1, 64, 1, 64, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 3, 66, 792,
		8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 5, 66, 798, 8, 66, 10, 66, 12, 66, 801,
		9, 66, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 0, 13, 2, 24, 34, 62, 68, 72,
		90, 94, 98, 100, 102, 112, 132, 69, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18,
		20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54,
		56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90,
		92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
		122, 124, 126, 128, 130, 132, 134, 136, 0, 10, 1, 0, 32, 37, 1, 0, 21,
		23, 1, 0, 19, 20, 1, 0, 27, 30, 1, 0, 25, 26, 2, 0, 41, 41, 46, 46, 1,
		0, 42, 43, 1, 0, 39, 40, 1, 0, 44, 45, 1, 0, 17, 18, 861, 0, 138, 1, 0,
		0, 0, 2, 146, 1, 0, 0, 0, 4, 165, 1, 0, 0, 0, 6, 167, 1, 0, 0, 0, 8, 171,
		1, 0, 0, 0, 10, 175, 1, 0, 0, 0, 12, 177, 1, 0, 0, 0, 14, 179, 1, 0, 0,
		0, 16, 183, 1, 0, 0, 0, 18, 194, 1, 0, 0, 0, 20, 198, 1, 0, 0, 0, 22, 207,
		1, 0, 0, 0, 24, 209, 1, 0, 0, 0, 26, 220, 1, 0, 0, 0, 28, 222, 1, 0, 0,
		0, 30, 237, 1, 0, 0, 0, 32, 239, 1, 0, 0, 0, 34, 241, 1, 0, 0, 0, 36, 254,
		1, 0, 0, 0, 38, 260, 1, 0, 0, 0, 40, 262, 1, 0, 0, 0, 42, 270, 1, 0, 0,
		0, 44, 277, 1, 0, 0, 0, 46, 279, 1, 0, 0, 0, 48, 300, 1, 0, 0, 0, 50, 324,
		1, 0, 0, 0, 52, 348, 1, 0, 0, 0, 54, 350, 1, 0, 0, 0, 56, 378, 1, 0, 0,
		0, 58, 380, 1, 0, 0, 0, 60, 386, 1, 0, 0, 0, 62, 388, 1, 0, 0, 0, 64, 399,
		1, 0, 0, 0, 66, 401, 1, 0, 0, 0, 68, 403, 1, 0, 0, 0, 70, 414, 1, 0, 0,
		0, 72, 425, 1, 0, 0, 0, 74, 451, 1, 0, 0, 0, 76, 461, 1, 0, 0, 0, 78, 471,
		1, 0, 0, 0, 80, 481, 1, 0, 0, 0, 82, 491, 1, 0, 0, 0, 84, 493, 1, 0, 0,
		0, 86, 498, 1, 0, 0, 0, 88, 502, 1, 0, 0, 0, 90, 506, 1, 0, 0, 0, 92, 538,
		1, 0, 0, 0, 94, 566, 1, 0, 0, 0, 96, 597, 1, 0, 0, 0, 98, 605, 1, 0, 0,
		0, 100, 632, 1, 0, 0, 0, 102, 657, 1, 0, 0, 0, 104, 691, 1, 0, 0, 0, 106,
		701, 1, 0, 0, 0, 108, 706, 1, 0, 0, 0, 110, 708, 1, 0, 0, 0, 112, 736,
		1, 0, 0, 0, 114, 770, 1, 0, 0, 0, 116, 772, 1, 0, 0, 0, 118, 774, 1, 0,
		0, 0, 120, 776, 1, 0, 0, 0, 122, 778, 1, 0, 0, 0, 124, 780, 1, 0, 0, 0,
		126, 782, 1, 0, 0, 0, 128, 784, 1, 0, 0, 0, 130, 786, 1, 0, 0, 0, 132,
		791, 1, 0, 0, 0, 134, 802, 1, 0, 0, 0, 136, 804, 1, 0, 0, 0, 138, 139,
		3, 2, 1, 0, 139, 140, 5, 0, 0, 1, 140, 1, 1, 0, 0, 0, 141, 142, 6, 1, -1,
		0, 142, 143, 3, 4, 2, 0, 143, 144, 3, 132, 66, 0, 144, 147, 1, 0, 0, 0,
		145, 147, 3, 132, 66, 0, 146, 141, 1, 0, 0, 0, 146, 145, 1, 0, 0, 0, 147,
		154, 1, 0, 0, 0, 148, 149, 10, 2, 0, 0, 149, 150, 3, 4, 2, 0, 150, 151,
		3, 132, 66, 0, 151, 153, 1, 0, 0, 0, 152, 148, 1, 0, 0, 0, 153, 156, 1,
		0, 0, 0, 154, 152, 1, 0, 0, 0, 154, 155, 1, 0, 0, 0, 155, 3, 1, 0, 0, 0,
		156, 154, 1, 0, 0, 0, 157, 166, 3, 14, 7, 0, 158, 166, 3, 12, 6, 0, 159,
		166, 3, 50, 25, 0, 160, 166, 3, 52, 26, 0, 161, 166, 3, 112, 56, 0, 162,
		166, 3, 28, 14, 0, 163, 166, 3, 54, 27, 0, 164, 166, 3, 56, 28, 0, 165,
		157, 1, 0, 0, 0, 165, 158, 1, 0, 0, 0, 165, 159, 1, 0, 0, 0, 165, 160,
		1, 0, 0, 0, 165, 161, 1, 0, 0, 0, 165, 162, 1, 0, 0, 0, 165, 163, 1, 0,
		0, 0, 165, 164, 1, 0, 0, 0, 166, 5, 1, 0, 0, 0, 167, 168, 3, 110, 55, 0,
		168, 169, 5, 31, 0, 0, 169, 170, 3, 128, 64, 0, 170, 7, 1, 0, 0, 0, 171,
		172, 3, 128, 64, 0, 172, 173, 5, 31, 0, 0, 173, 174, 3, 44, 22, 0, 174,
		9, 1, 0, 0, 0, 175, 176, 3, 128, 64, 0, 176, 11, 1, 0, 0, 0, 177, 178,
		3, 30, 15, 0, 178, 13, 1, 0, 0, 0, 179, 180, 3, 18, 9, 0, 180, 181, 3,
		16, 8, 0, 181, 182, 5, 5, 0, 0, 182, 15, 1, 0, 0, 0, 183, 184, 3, 2, 1,
		0, 184, 17, 1, 0, 0, 0, 185, 186, 5, 6, 0, 0, 186, 187, 3, 20, 10, 0, 187,
		188, 3, 136, 68, 0, 188, 195, 1, 0, 0, 0, 189, 190, 5, 6, 0, 0, 190, 191,
		3, 20, 10, 0, 191, 192, 3, 22, 11, 0, 192, 193, 3, 136, 68, 0, 193, 195,
		1, 0, 0, 0, 194, 185, 1, 0, 0, 0, 194, 189, 1, 0, 0, 0, 195, 19, 1, 0,
		0, 0, 196, 199, 3, 130, 65, 0, 197, 199, 3, 126, 63, 0, 198, 196, 1, 0,
		0, 0, 198, 197, 1, 0, 0, 0, 199, 21, 1, 0, 0, 0, 200, 201, 5, 47, 0, 0,
		201, 208, 5, 48, 0, 0, 202, 203, 5, 47, 0, 0, 203, 204, 3, 24, 12, 0, 204,
		205, 5, 48, 0, 0, 205, 208, 1, 0, 0, 0, 206, 208, 3, 24, 12, 0, 207, 200,
		1, 0, 0, 0, 207, 202, 1, 0, 0, 0, 207, 206, 1, 0, 0, 0, 208, 23, 1, 0,
		0, 0, 209, 210, 6, 12, -1, 0, 210, 211, 3, 26, 13, 0, 211, 217, 1, 0, 0,
		0, 212, 213, 10, 1, 0, 0, 213, 214, 5, 2, 0, 0, 214, 216, 3, 26, 13, 0,
		215, 212, 1, 0, 0, 0, 216, 219, 1, 0, 0, 0, 217, 215, 1, 0, 0, 0, 217,
		218, 1, 0, 0, 0, 218, 25, 1, 0, 0, 0, 219, 217, 1, 0, 0, 0, 220, 221, 3,
		126, 63, 0, 221, 27, 1, 0, 0, 0, 222, 223, 5, 7, 0, 0, 223, 224, 3, 44,
		22, 0, 224, 29, 1, 0, 0, 0, 225, 226, 3, 20, 10, 0, 226, 227, 5, 47, 0,
		0, 227, 228, 3, 32, 16, 0, 228, 229, 5, 48, 0, 0, 229, 238, 1, 0, 0, 0,
		230, 231, 3, 20, 10, 0, 231, 232, 3, 32, 16, 0, 232, 238, 1, 0, 0, 0, 233,
		234, 3, 20, 10, 0, 234, 235, 5, 47, 0, 0, 235, 236, 5, 48, 0, 0, 236, 238,
		1, 0, 0, 0, 237, 225, 1, 0, 0, 0, 237, 230, 1, 0, 0, 0, 237, 233, 1, 0,
		0, 0, 238, 31, 1, 0, 0, 0, 239, 240, 3, 34, 17, 0, 240, 33, 1, 0, 0, 0,
		241, 242, 6, 17, -1, 0, 242, 243, 3, 36, 18, 0, 243, 249, 1, 0, 0, 0, 244,
		245, 10, 1, 0, 0, 245, 246, 5, 2, 0, 0, 246, 248, 3, 36, 18, 0, 247, 244,
		1, 0, 0, 0, 248, 251, 1, 0, 0, 0, 249, 247, 1, 0, 0, 0, 249, 250, 1, 0,
		0, 0, 250, 35, 1, 0, 0, 0, 251, 249, 1, 0, 0, 0, 252, 255, 3, 38, 19, 0,
		253, 255, 3, 40, 20, 0, 254, 252, 1, 0, 0, 0, 254, 253, 1, 0, 0, 0, 255,
		37, 1, 0, 0, 0, 256, 261, 3, 98, 49, 0, 257, 261, 3, 100, 50, 0, 258, 261,
		3, 102, 51, 0, 259, 261, 3, 94, 47, 0, 260, 256, 1, 0, 0, 0, 260, 257,
		1, 0, 0, 0, 260, 258, 1, 0, 0, 0, 260, 259, 1, 0, 0, 0, 261, 39, 1, 0,
		0, 0, 262, 263, 3, 126, 63, 0, 263, 268, 5, 31, 0, 0, 264, 269, 3, 98,
		49, 0, 265, 269, 3, 100, 50, 0, 266, 269, 3, 102, 51, 0, 267, 269, 3, 94,
		47, 0, 268, 264, 1, 0, 0, 0, 268, 265, 1, 0, 0, 0, 268, 266, 1, 0, 0, 0,
		268, 267, 1, 0, 0, 0, 269, 41, 1, 0, 0, 0, 270, 271, 3, 30, 15, 0, 271,
		43, 1, 0, 0, 0, 272, 278, 3, 98, 49, 0, 273, 278, 3, 100, 50, 0, 274, 278,
		3, 102, 51, 0, 275, 278, 3, 94, 47, 0, 276, 278, 3, 10, 5, 0, 277, 272,
		1, 0, 0, 0, 277, 273, 1, 0, 0, 0, 277, 274, 1, 0, 0, 0, 277, 275, 1, 0,
		0, 0, 277, 276, 1, 0, 0, 0, 278, 45, 1, 0, 0, 0, 279, 280, 3, 48, 24, 0,
		280, 47, 1, 0, 0, 0, 281, 282, 5, 11, 0, 0, 282, 283, 3, 64, 32, 0, 283,
		284, 3, 136, 68, 0, 284, 285, 3, 70, 35, 0, 285, 301, 1, 0, 0, 0, 286,
		287, 5, 11, 0, 0, 287, 288, 3, 64, 32, 0, 288, 289, 3, 136, 68, 0, 289,
		290, 3, 70, 35, 0, 290, 291, 3, 134, 67, 0, 291, 292, 3, 136, 68, 0, 292,
		293, 3, 70, 35, 0, 293, 301, 1, 0, 0, 0, 294, 295, 5, 11, 0, 0, 295, 296,
		3, 64, 32, 0, 296, 297, 3, 136, 68, 0, 297, 298, 3, 70, 35, 0, 298, 299,
		3, 48, 24, 0, 299, 301, 1, 0, 0, 0, 300, 281, 1, 0, 0, 0, 300, 286, 1,
		0, 0, 0, 300, 294, 1, 0, 0, 0, 301, 49, 1, 0, 0, 0, 302, 303, 5, 9, 0,
		0, 303, 304, 3, 64, 32, 0, 304, 305, 3, 136, 68, 0, 305, 306, 3, 70, 35,
		0, 306, 307, 5, 5, 0, 0, 307, 325, 1, 0, 0, 0, 308, 309, 5, 9, 0, 0, 309,
		310, 3, 64, 32, 0, 310, 311, 3, 136, 68, 0, 311, 312, 3, 70, 35, 0, 312,
		313, 3, 134, 67, 0, 313, 314, 3, 136, 68, 0, 314, 315, 3, 70, 35, 0, 315,
		316, 5, 5, 0, 0, 316, 325, 1, 0, 0, 0, 317, 318, 5, 9, 0, 0, 318, 319,
		3, 64, 32, 0, 319, 320, 3, 136, 68, 0, 320, 321, 3, 70, 35, 0, 321, 322,
		3, 46, 23, 0, 322, 323, 5, 5, 0, 0, 323, 325, 1, 0, 0, 0, 324, 302, 1,
		0, 0, 0, 324, 308, 1, 0, 0, 0, 324, 317, 1, 0, 0, 0, 325, 51, 1, 0, 0,
		0, 326, 327, 5, 12, 0, 0, 327, 328, 3, 64, 32, 0, 328, 329, 3, 136, 68,
		0, 329, 330, 3, 70, 35, 0, 330, 331, 5, 5, 0, 0, 331, 349, 1, 0, 0, 0,
		332, 333, 5, 12, 0, 0, 333, 334, 3, 64, 32, 0, 334, 335, 3, 136, 68, 0,
		335, 336, 3, 70, 35, 0, 336, 337, 3, 134, 67, 0, 337, 338, 3, 136, 68,
		0, 338, 339, 3, 70, 35, 0, 339, 340, 5, 5, 0, 0, 340, 349, 1, 0, 0, 0,
		341, 342, 5, 12, 0, 0, 342, 343, 3, 64, 32, 0, 343, 344, 3, 136, 68, 0,
		344, 345, 3, 70, 35, 0, 345, 346, 3, 46, 23, 0, 346, 347, 5, 5, 0, 0, 347,
		349, 1, 0, 0, 0, 348, 326, 1, 0, 0, 0, 348, 332, 1, 0, 0, 0, 348, 341,
		1, 0, 0, 0, 349, 53, 1, 0, 0, 0, 350, 351, 5, 13, 0, 0, 351, 352, 3, 64,
		32, 0, 352, 353, 3, 136, 68, 0, 353, 354, 3, 70, 35, 0, 354, 355, 5, 5,
		0, 0, 355, 55, 1, 0, 0, 0, 356, 357, 5, 16, 0, 0, 357, 358, 5, 47, 0, 0,
		358, 359, 3, 58, 29, 0, 359, 360, 5, 3, 0, 0, 360, 361, 3, 64, 32, 0, 361,
		362, 5, 3, 0, 0, 362, 363, 3, 66, 33, 0, 363, 364, 5, 48, 0, 0, 364, 365,
		3, 136, 68, 0, 365, 366, 3, 70, 35, 0, 366, 367, 5, 5, 0, 0, 367, 379,
		1, 0, 0, 0, 368, 369, 5, 16, 0, 0, 369, 370, 3, 58, 29, 0, 370, 371, 5,
		3, 0, 0, 371, 372, 3, 64, 32, 0, 372, 373, 5, 3, 0, 0, 373, 374, 3, 66,
		33, 0, 374, 375, 3, 136, 68, 0, 375, 376, 3, 70, 35, 0, 376, 377, 5, 5,
		0, 0, 377, 379, 1, 0, 0, 0, 378, 356, 1, 0, 0, 0, 378, 368, 1, 0, 0, 0,
		379, 57, 1, 0, 0, 0, 380, 381, 3, 62, 31, 0, 381, 59, 1, 0, 0, 0, 382,
		387, 3, 78, 39, 0, 383, 387, 3, 80, 40, 0, 384, 387, 3, 82, 41, 0, 385,
		387, 3, 76, 38, 0, 386, 382, 1, 0, 0, 0, 386, 383, 1, 0, 0, 0, 386, 384,
		1, 0, 0, 0, 386, 385, 1, 0, 0, 0, 387, 61, 1, 0, 0, 0, 388, 389, 6, 31,
		-1, 0, 389, 390, 3, 60, 30, 0, 390, 396, 1, 0, 0, 0, 391, 392, 10, 2, 0,
		0, 392, 393, 5, 2, 0, 0, 393, 395, 3, 60, 30, 0, 394, 391, 1, 0, 0, 0,
		395, 398, 1, 0, 0, 0, 396, 394, 1, 0, 0, 0, 396, 397, 1, 0, 0, 0, 397,
		63, 1, 0, 0, 0, 398, 396, 1, 0, 0, 0, 399, 400, 3, 104, 52, 0, 400, 65,
		1, 0, 0, 0, 401, 402, 3, 68, 34, 0, 402, 67, 1, 0, 0, 0, 403, 404, 6, 34,
		-1, 0, 404, 405, 3, 60, 30, 0, 405, 411, 1, 0, 0, 0, 406, 407, 10, 2, 0,
		0, 407, 408, 5, 2, 0, 0, 408, 410, 3, 60, 30, 0, 409, 406, 1, 0, 0, 0,
		410, 413, 1, 0, 0, 0, 411, 409, 1, 0, 0, 0, 411, 412, 1, 0, 0, 0, 412,
		69, 1, 0, 0, 0, 413, 411, 1, 0, 0, 0, 414, 415, 3, 72, 36, 0, 415, 71,
		1, 0, 0, 0, 416, 417, 6, 36, -1, 0, 417, 418, 3, 4, 2, 0, 418, 419, 3,
		132, 66, 0, 419, 426, 1, 0, 0, 0, 420, 421, 5, 14, 0, 0, 421, 426, 3, 132,
		66, 0, 422, 423, 3, 114, 57, 0, 423, 424, 3, 132, 66, 0, 424, 426, 1, 0,
		0, 0, 425, 416, 1, 0, 0, 0, 425, 420, 1, 0, 0, 0, 425, 422, 1, 0, 0, 0,
		426, 440, 1, 0, 0, 0, 427, 428, 10, 3, 0, 0, 428, 429, 3, 4, 2, 0, 429,
		430, 3, 132, 66, 0, 430, 439, 1, 0, 0, 0, 431, 432, 10, 2, 0, 0, 432, 433,
		5, 14, 0, 0, 433, 439, 3, 132, 66, 0, 434, 435, 10, 1, 0, 0, 435, 436,
		3, 114, 57, 0, 436, 437, 3, 132, 66, 0, 437, 439, 1, 0, 0, 0, 438, 427,
		1, 0, 0, 0, 438, 431, 1, 0, 0, 0, 438, 434, 1, 0, 0, 0, 439, 442, 1, 0,
		0, 0, 440, 438, 1, 0, 0, 0, 440, 441, 1, 0, 0, 0, 441, 73, 1, 0, 0, 0,
		442, 440, 1, 0, 0, 0, 443, 444, 3, 110, 55, 0, 444, 445, 5, 31, 0, 0, 445,
		446, 3, 112, 56, 0, 446, 452, 1, 0, 0, 0, 447, 448, 3, 110, 55, 0, 448,
		449, 7, 0, 0, 0, 449, 450, 3, 112, 56, 0, 450, 452, 1, 0, 0, 0, 451, 443,
		1, 0, 0, 0, 451, 447, 1, 0, 0, 0, 452, 75, 1, 0, 0, 0, 453, 454, 3, 110,
		55, 0, 454, 455, 5, 31, 0, 0, 455, 456, 3, 94, 47, 0, 456, 462, 1, 0, 0,
		0, 457, 458, 3, 110, 55, 0, 458, 459, 7, 0, 0, 0, 459, 460, 3, 94, 47,
		0, 460, 462, 1, 0, 0, 0, 461, 453, 1, 0, 0, 0, 461, 457, 1, 0, 0, 0, 462,
		77, 1, 0, 0, 0, 463, 464, 3, 110, 55, 0, 464, 465, 5, 31, 0, 0, 465, 466,
		3, 98, 49, 0, 466, 472, 1, 0, 0, 0, 467, 468, 3, 110, 55, 0, 468, 469,
		7, 0, 0, 0, 469, 470, 3, 98, 49, 0, 470, 472, 1, 0, 0, 0, 471, 463, 1,
		0, 0, 0, 471, 467, 1, 0, 0, 0, 472, 79, 1, 0, 0, 0, 473, 474, 3, 110, 55,
		0, 474, 475, 5, 31, 0, 0, 475, 476, 3, 100, 50, 0, 476, 482, 1, 0, 0, 0,
		477, 478, 3, 110, 55, 0, 478, 479, 7, 0, 0, 0, 479, 480, 3, 100, 50, 0,
		480, 482, 1, 0, 0, 0, 481, 473, 1, 0, 0, 0, 481, 477, 1, 0, 0, 0, 482,
		81, 1, 0, 0, 0, 483, 484, 3, 110, 55, 0, 484, 485, 5, 31, 0, 0, 485, 486,
		3, 102, 51, 0, 486, 492, 1, 0, 0, 0, 487, 488, 3, 110, 55, 0, 488, 489,
		5, 32, 0, 0, 489, 490, 3, 102, 51, 0, 490, 492, 1, 0, 0, 0, 491, 483, 1,
		0, 0, 0, 491, 487, 1, 0, 0, 0, 492, 83, 1, 0, 0, 0, 493, 494, 3, 110, 55,
		0, 494, 495, 5, 31, 0, 0, 495, 496, 5, 49, 0, 0, 496, 497, 5, 50, 0, 0,
		497, 85, 1, 0, 0, 0, 498, 499, 3, 92, 46, 0, 499, 500, 5, 31, 0, 0, 500,
		501, 3, 44, 22, 0, 501, 87, 1, 0, 0, 0, 502, 503, 5, 49, 0, 0, 503, 504,
		3, 90, 45, 0, 504, 505, 5, 50, 0, 0, 505, 89, 1, 0, 0, 0, 506, 509, 6,
		45, -1, 0, 507, 510, 3, 98, 49, 0, 508, 510, 3, 94, 47, 0, 509, 507, 1,
		0, 0, 0, 509, 508, 1, 0, 0, 0, 510, 519, 1, 0, 0, 0, 511, 512, 10, 1, 0,
		0, 512, 515, 5, 2, 0, 0, 513, 516, 3, 98, 49, 0, 514, 516, 3, 94, 47, 0,
		515, 513, 1, 0, 0, 0, 515, 514, 1, 0, 0, 0, 516, 518, 1, 0, 0, 0, 517,
		511, 1, 0, 0, 0, 518, 521, 1, 0, 0, 0, 519, 517, 1, 0, 0, 0, 519, 520,
		1, 0, 0, 0, 520, 91, 1, 0, 0, 0, 521, 519, 1, 0, 0, 0, 522, 523, 3, 126,
		63, 0, 523, 526, 5, 49, 0, 0, 524, 527, 3, 98, 49, 0, 525, 527, 3, 94,
		47, 0, 526, 524, 1, 0, 0, 0, 526, 525, 1, 0, 0, 0, 527, 528, 1, 0, 0, 0,
		528, 529, 5, 50, 0, 0, 529, 539, 1, 0, 0, 0, 530, 531, 3, 128, 64, 0, 531,
		534, 5, 49, 0, 0, 532, 535, 3, 98, 49, 0, 533, 535, 3, 94, 47, 0, 534,
		532, 1, 0, 0, 0, 534, 533, 1, 0, 0, 0, 535, 536, 1, 0, 0, 0, 536, 537,
		5, 50, 0, 0, 537, 539, 1, 0, 0, 0, 538, 522, 1, 0, 0, 0, 538, 530, 1, 0,
		0, 0, 539, 93, 1, 0, 0, 0, 540, 541, 6, 47, -1, 0, 541, 542, 3, 98, 49,
		0, 542, 543, 7, 1, 0, 0, 543, 544, 3, 94, 47, 13, 544, 567, 1, 0, 0, 0,
		545, 546, 3, 100, 50, 0, 546, 547, 7, 1, 0, 0, 547, 548, 3, 94, 47, 11,
		548, 567, 1, 0, 0, 0, 549, 550, 3, 102, 51, 0, 550, 551, 5, 21, 0, 0, 551,
		552, 3, 94, 47, 8, 552, 567, 1, 0, 0, 0, 553, 554, 3, 98, 49, 0, 554, 555,
		7, 2, 0, 0, 555, 556, 3, 94, 47, 6, 556, 567, 1, 0, 0, 0, 557, 558, 3,
		100, 50, 0, 558, 559, 7, 2, 0, 0, 559, 560, 3, 94, 47, 4, 560, 567, 1,
		0, 0, 0, 561, 562, 5, 47, 0, 0, 562, 563, 3, 94, 47, 0, 563, 564, 5, 48,
		0, 0, 564, 567, 1, 0, 0, 0, 565, 567, 3, 96, 48, 0, 566, 540, 1, 0, 0,
		0, 566, 545, 1, 0, 0, 0, 566, 549, 1, 0, 0, 0, 566, 553, 1, 0, 0, 0, 566,
		557, 1, 0, 0, 0, 566, 561, 1, 0, 0, 0, 566, 565, 1, 0, 0, 0, 567, 591,
		1, 0, 0, 0, 568, 569, 10, 10, 0, 0, 569, 570, 7, 1, 0, 0, 570, 590, 3,
		94, 47, 11, 571, 572, 10, 3, 0, 0, 572, 573, 7, 2, 0, 0, 573, 590, 3, 94,
		47, 4, 574, 575, 10, 14, 0, 0, 575, 576, 7, 1, 0, 0, 576, 590, 3, 98, 49,
		0, 577, 578, 10, 12, 0, 0, 578, 579, 7, 1, 0, 0, 579, 590, 3, 100, 50,
		0, 580, 581, 10, 9, 0, 0, 581, 582, 5, 21, 0, 0, 582, 590, 3, 102, 51,
		0, 583, 584, 10, 7, 0, 0, 584, 585, 7, 2, 0, 0, 585, 590, 3, 98, 49, 0,
		586, 587, 10, 5, 0, 0, 587, 588, 7, 2, 0, 0, 588, 590, 3, 100, 50, 0, 589,
		568, 1, 0, 0, 0, 589, 571, 1, 0, 0, 0, 589, 574, 1, 0, 0, 0, 589, 577,
		1, 0, 0, 0, 589, 580, 1, 0, 0, 0, 589, 583, 1, 0, 0, 0, 589, 586, 1, 0,
		0, 0, 590, 593, 1, 0, 0, 0, 591, 589, 1, 0, 0, 0, 591, 592, 1, 0, 0, 0,
		592, 95, 1, 0, 0, 0, 593, 591, 1, 0, 0, 0, 594, 598, 3, 126, 63, 0, 595,
		598, 3, 42, 21, 0, 596, 598, 3, 92, 46, 0, 597, 594, 1, 0, 0, 0, 597, 595,
		1, 0, 0, 0, 597, 596, 1, 0, 0, 0, 598, 97, 1, 0, 0, 0, 599, 600, 6, 49,
		-1, 0, 600, 601, 5, 47, 0, 0, 601, 602, 3, 98, 49, 0, 602, 603, 5, 48,
		0, 0, 603, 606, 1, 0, 0, 0, 604, 606, 3, 120, 60, 0, 605, 599, 1, 0, 0,
		0, 605, 604, 1, 0, 0, 0, 606, 615, 1, 0, 0, 0, 607, 608, 10, 4, 0, 0, 608,
		609, 7, 1, 0, 0, 609, 614, 3, 98, 49, 5, 610, 611, 10, 3, 0, 0, 611, 612,
		7, 2, 0, 0, 612, 614, 3, 98, 49, 4, 613, 607, 1, 0, 0, 0, 613, 610, 1,
		0, 0, 0, 614, 617, 1, 0, 0, 0, 615, 613, 1, 0, 0, 0, 615, 616, 1, 0, 0,
		0, 616, 99, 1, 0, 0, 0, 617, 615, 1, 0, 0, 0, 618, 619, 6, 50, -1, 0, 619,
		620, 3, 98, 49, 0, 620, 621, 7, 1, 0, 0, 621, 622, 3, 100, 50, 7, 622,
		633, 1, 0, 0, 0, 623, 624, 3, 98, 49, 0, 624, 625, 7, 2, 0, 0, 625, 626,
		3, 100, 50, 4, 626, 633, 1, 0, 0, 0, 627, 628, 5, 47, 0, 0, 628, 629, 3,
		100, 50, 0, 629, 630, 5, 48, 0, 0, 630, 633, 1, 0, 0, 0, 631, 633, 3, 118,
		59, 0, 632, 618, 1, 0, 0, 0, 632, 623, 1, 0, 0, 0, 632, 627, 1, 0, 0, 0,
		632, 631, 1, 0, 0, 0, 633, 648, 1, 0, 0, 0, 634, 635, 10, 8, 0, 0, 635,
		636, 7, 1, 0, 0, 636, 647, 3, 100, 50, 9, 637, 638, 10, 5, 0, 0, 638, 639,
		7, 2, 0, 0, 639, 647, 3, 100, 50, 6, 640, 641, 10, 6, 0, 0, 641, 642, 7,
		1, 0, 0, 642, 647, 3, 98, 49, 0, 643, 644, 10, 3, 0, 0, 644, 645, 7, 2,
		0, 0, 645, 647, 3, 98, 49, 0, 646, 634, 1, 0, 0, 0, 646, 637, 1, 0, 0,
		0, 646, 640, 1, 0, 0, 0, 646, 643, 1, 0, 0, 0, 647, 650, 1, 0, 0, 0, 648,
		646, 1, 0, 0, 0, 648, 649, 1, 0, 0, 0, 649, 101, 1, 0, 0, 0, 650, 648,
		1, 0, 0, 0, 651, 652, 6, 51, -1, 0, 652, 653, 3, 98, 49, 0, 653, 654, 5,
		21, 0, 0, 654, 655, 3, 102, 51, 3, 655, 658, 1, 0, 0, 0, 656, 658, 3, 116,
		58, 0, 657, 651, 1, 0, 0, 0, 657, 656, 1, 0, 0, 0, 658, 667, 1, 0, 0, 0,
		659, 660, 10, 2, 0, 0, 660, 661, 5, 19, 0, 0, 661, 666, 3, 102, 51, 3,
		662, 663, 10, 4, 0, 0, 663, 664, 5, 21, 0, 0, 664, 666, 3, 98, 49, 0, 665,
		659, 1, 0, 0, 0, 665, 662, 1, 0, 0, 0, 666, 669, 1, 0, 0, 0, 667, 665,
		1, 0, 0, 0, 667, 668, 1, 0, 0, 0, 668, 103, 1, 0, 0, 0, 669, 667, 1, 0,
		0, 0, 670, 671, 3, 106, 53, 0, 671, 672, 5, 38, 0, 0, 672, 673, 3, 104,
		52, 0, 673, 692, 1, 0, 0, 0, 674, 675, 3, 106, 53, 0, 675, 676, 5, 44,
		0, 0, 676, 677, 3, 104, 52, 0, 677, 692, 1, 0, 0, 0, 678, 679, 3, 106,
		53, 0, 679, 680, 5, 39, 0, 0, 680, 681, 3, 104, 52, 0, 681, 692, 1, 0,
		0, 0, 682, 683, 3, 106, 53, 0, 683, 684, 5, 45, 0, 0, 684, 685, 3, 104,
		52, 0, 685, 692, 1, 0, 0, 0, 686, 687, 5, 47, 0, 0, 687, 688, 3, 104, 52,
		0, 688, 689, 5, 48, 0, 0, 689, 692, 1, 0, 0, 0, 690, 692, 3, 106, 53, 0,
		691, 670, 1, 0, 0, 0, 691, 674, 1, 0, 0, 0, 691, 678, 1, 0, 0, 0, 691,
		682, 1, 0, 0, 0, 691, 686, 1, 0, 0, 0, 691, 690, 1, 0, 0, 0, 692, 105,
		1, 0, 0, 0, 693, 694, 3, 108, 54, 0, 694, 695, 7, 3, 0, 0, 695, 696, 3,
		108, 54, 0, 696, 702, 1, 0, 0, 0, 697, 698, 3, 108, 54, 0, 698, 699, 7,
		4, 0, 0, 699, 700, 3, 108, 54, 0, 700, 702, 1, 0, 0, 0, 701, 693, 1, 0,
		0, 0, 701, 697, 1, 0, 0, 0, 702, 107, 1, 0, 0, 0, 703, 707, 3, 44, 22,
		0, 704, 707, 3, 92, 46, 0, 705, 707, 3, 126, 63, 0, 706, 703, 1, 0, 0,
		0, 706, 704, 1, 0, 0, 0, 706, 705, 1, 0, 0, 0, 707, 109, 1, 0, 0, 0, 708,
		709, 3, 126, 63, 0, 709, 111, 1, 0, 0, 0, 710, 711, 6, 56, -1, 0, 711,
		737, 3, 110, 55, 0, 712, 737, 3, 84, 42, 0, 713, 737, 3, 86, 43, 0, 714,
		737, 3, 98, 49, 0, 715, 737, 3, 100, 50, 0, 716, 737, 3, 102, 51, 0, 717,
		737, 3, 8, 4, 0, 718, 737, 3, 6, 3, 0, 719, 737, 3, 76, 38, 0, 720, 737,
		3, 82, 41, 0, 721, 737, 3, 80, 40, 0, 722, 737, 3, 78, 39, 0, 723, 737,
		3, 74, 37, 0, 724, 737, 3, 30, 15, 0, 725, 737, 3, 116, 58, 0, 726, 737,
		3, 122, 61, 0, 727, 737, 3, 118, 59, 0, 728, 737, 3, 120, 60, 0, 729, 737,
		3, 124, 62, 0, 730, 731, 7, 5, 0, 0, 731, 737, 3, 112, 56, 10, 732, 733,
		5, 47, 0, 0, 733, 734, 3, 112, 56, 0, 734, 735, 5, 48, 0, 0, 735, 737,
		1, 0, 0, 0, 736, 710, 1, 0, 0, 0, 736, 712, 1, 0, 0, 0, 736, 713, 1, 0,
		0, 0, 736, 714, 1, 0, 0, 0, 736, 715, 1, 0, 0, 0, 736, 716, 1, 0, 0, 0,
		736, 717, 1, 0, 0, 0, 736, 718, 1, 0, 0, 0, 736, 719, 1, 0, 0, 0, 736,
		720, 1, 0, 0, 0, 736, 721, 1, 0, 0, 0, 736, 722, 1, 0, 0, 0, 736, 723,
		1, 0, 0, 0, 736, 724, 1, 0, 0, 0, 736, 725, 1, 0, 0, 0, 736, 726, 1, 0,
		0, 0, 736, 727, 1, 0, 0, 0, 736, 728, 1, 0, 0, 0, 736, 729, 1, 0, 0, 0,
		736, 730, 1, 0, 0, 0, 736, 732, 1, 0, 0, 0, 737, 767, 1, 0, 0, 0, 738,
		739, 10, 11, 0, 0, 739, 740, 5, 24, 0, 0, 740, 766, 3, 112, 56, 12, 741,
		742, 10, 9, 0, 0, 742, 743, 7, 1, 0, 0, 743, 766, 3, 112, 56, 10, 744,
		745, 10, 8, 0, 0, 745, 746, 7, 2, 0, 0, 746, 766, 3, 112, 56, 9, 747, 748,
		10, 7, 0, 0, 748, 749, 7, 6, 0, 0, 749, 766, 3, 112, 56, 8, 750, 751, 10,
		6, 0, 0, 751, 752, 5, 38, 0, 0, 752, 766, 3, 112, 56, 7, 753, 754, 10,
		5, 0, 0, 754, 755, 7, 7, 0, 0, 755, 766, 3, 112, 56, 6, 756, 757, 10, 4,
		0, 0, 757, 758, 7, 3, 0, 0, 758, 766, 3, 112, 56, 5, 759, 760, 10, 3, 0,
		0, 760, 761, 7, 4, 0, 0, 761, 766, 3, 112, 56, 4, 762, 763, 10, 2, 0, 0,
		763, 764, 7, 8, 0, 0, 764, 766, 3, 112, 56, 3, 765, 738, 1, 0, 0, 0, 765,
		741, 1, 0, 0, 0, 765, 744, 1, 0, 0, 0, 765, 747, 1, 0, 0, 0, 765, 750,
		1, 0, 0, 0, 765, 753, 1, 0, 0, 0, 765, 756, 1, 0, 0, 0, 765, 759, 1, 0,
		0, 0, 765, 762, 1, 0, 0, 0, 766, 769, 1, 0, 0, 0, 767, 765, 1, 0, 0, 0,
		767, 768, 1, 0, 0, 0, 768, 113, 1, 0, 0, 0, 769, 767, 1, 0, 0, 0, 770,
		771, 5, 15, 0, 0, 771, 115, 1, 0, 0, 0, 772, 773, 5, 1, 0, 0, 773, 117,
		1, 0, 0, 0, 774, 775, 5, 56, 0, 0, 775, 119, 1, 0, 0, 0, 776, 777, 5, 55,
		0, 0, 777, 121, 1, 0, 0, 0, 778, 779, 7, 9, 0, 0, 779, 123, 1, 0, 0, 0,
		780, 781, 5, 51, 0, 0, 781, 125, 1, 0, 0, 0, 782, 783, 5, 57, 0, 0, 783,
		127, 1, 0, 0, 0, 784, 785, 5, 58, 0, 0, 785, 129, 1, 0, 0, 0, 786, 787,
		5, 59, 0, 0, 787, 131, 1, 0, 0, 0, 788, 789, 6, 66, -1, 0, 789, 792, 5,
		3, 0, 0, 790, 792, 3, 136, 68, 0, 791, 788, 1, 0, 0, 0, 791, 790, 1, 0,
		0, 0, 792, 799, 1, 0, 0, 0, 793, 794, 10, 4, 0, 0, 794, 798, 5, 3, 0, 0,
		795, 796, 10, 3, 0, 0, 796, 798, 3, 136, 68, 0, 797, 793, 1, 0, 0, 0, 797,
		795, 1, 0, 0, 0, 798, 801, 1, 0, 0, 0, 799, 797, 1, 0, 0, 0, 799, 800,
		1, 0, 0, 0, 800, 133, 1, 0, 0, 0, 801, 799, 1, 0, 0, 0, 802, 803, 5, 10,
		0, 0, 803, 135, 1, 0, 0, 0, 804, 805, 5, 4, 0, 0, 805, 137, 1, 0, 0, 0,
		56, 146, 154, 165, 194, 198, 207, 217, 237, 249, 254, 260, 268, 277, 300,
		324, 348, 378, 386, 396, 411, 425, 438, 440, 451, 461, 471, 481, 491, 509,
		515, 519, 526, 534, 538, 566, 589, 591, 597, 605, 613, 615, 632, 646, 648,
		657, 665, 667, 691, 701, 706, 736, 765, 767, 791, 797, 799,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// RubyKParserInit initializes any static state used to implement RubyKParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewRubyKParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func RubyKParserInit() {
	staticData := &rubykParserStaticData
	staticData.once.Do(rubykParserInit)
}

// NewRubyKParser produces a new parser instance for the optional input antlr.TokenStream.
func NewRubyKParser(input antlr.TokenStream) *RubyKParser {
	RubyKParserInit()
	this := new(RubyKParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &rubykParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "RubyK.g4"

	return this
}

// RubyKParser tokens.
const (
	RubyKParserEOF            = antlr.TokenEOF
	RubyKParserLITERAL        = 1
	RubyKParserCOMMA          = 2
	RubyKParserSEMICOLON      = 3
	RubyKParserCRLF           = 4
	RubyKParserEND            = 5
	RubyKParserDEF            = 6
	RubyKParserRETURN         = 7
	RubyKParserPIR            = 8
	RubyKParserIF             = 9
	RubyKParserELSE           = 10
	RubyKParserELSIF          = 11
	RubyKParserUNLESS         = 12
	RubyKParserWHILE          = 13
	RubyKParserRETRY          = 14
	RubyKParserBREAK          = 15
	RubyKParserFOR            = 16
	RubyKParserTRUE           = 17
	RubyKParserFALSE          = 18
	RubyKParserPLUS           = 19
	RubyKParserMINUS          = 20
	RubyKParserMUL            = 21
	RubyKParserDIV            = 22
	RubyKParserMOD            = 23
	RubyKParserEXP            = 24
	RubyKParserEQUAL          = 25
	RubyKParserNOT_EQUAL      = 26
	RubyKParserGREATER        = 27
	RubyKParserLESS           = 28
	RubyKParserLESS_EQUAL     = 29
	RubyKParserGREATER_EQUAL  = 30
	RubyKParserASSIGN         = 31
	RubyKParserPLUS_ASSIGN    = 32
	RubyKParserMINUS_ASSIGN   = 33
	RubyKParserMUL_ASSIGN     = 34
	RubyKParserDIV_ASSIGN     = 35
	RubyKParserMOD_ASSIGN     = 36
	RubyKParserEXP_ASSIGN     = 37
	RubyKParserBIT_AND        = 38
	RubyKParserBIT_OR         = 39
	RubyKParserBIT_XOR        = 40
	RubyKParserBIT_NOT        = 41
	RubyKParserBIT_SHL        = 42
	RubyKParserBIT_SHR        = 43
	RubyKParserAND            = 44
	RubyKParserOR             = 45
	RubyKParserNOT            = 46
	RubyKParserLEFT_RBRACKET  = 47
	RubyKParserRIGHT_RBRACKET = 48
	RubyKParserLEFT_SBRACKET  = 49
	RubyKParserRIGHT_SBRACKET = 50
	RubyKParserNIL            = 51
	RubyKParserSL_COMMENT     = 52
	RubyKParserML_COMMENT     = 53
	RubyKParserWS             = 54
	RubyKParserINT            = 55
	RubyKParserFLOAT          = 56
	RubyKParserID             = 57
	RubyKParserID_GLOBAL      = 58
	RubyKParserID_FUNCTION    = 59
)

// RubyKParser rules.
const (
	RubyKParserRULE_program                         = 0
	RubyKParserRULE_expression_list                 = 1
	RubyKParserRULE_expression                      = 2
	RubyKParserRULE_global_get                      = 3
	RubyKParserRULE_global_set                      = 4
	RubyKParserRULE_global_result                   = 5
	RubyKParserRULE_function_inline_call            = 6
	RubyKParserRULE_function_definition             = 7
	RubyKParserRULE_function_definition_body        = 8
	RubyKParserRULE_function_definition_header      = 9
	RubyKParserRULE_function_name                   = 10
	RubyKParserRULE_function_definition_params      = 11
	RubyKParserRULE_function_definition_params_list = 12
	RubyKParserRULE_function_definition_param_id    = 13
	RubyKParserRULE_return_statement                = 14
	RubyKParserRULE_function_call                   = 15
	RubyKParserRULE_function_call_param_list        = 16
	RubyKParserRULE_function_call_params            = 17
	RubyKParserRULE_function_param                  = 18
	RubyKParserRULE_function_unnamed_param          = 19
	RubyKParserRULE_function_named_param            = 20
	RubyKParserRULE_function_call_assignment        = 21
	RubyKParserRULE_all_result                      = 22
	RubyKParserRULE_elsif_statement                 = 23
	RubyKParserRULE_if_elsif_statement              = 24
	RubyKParserRULE_if_statement                    = 25
	RubyKParserRULE_unless_statement                = 26
	RubyKParserRULE_while_statement                 = 27
	RubyKParserRULE_for_statement                   = 28
	RubyKParserRULE_init_expression                 = 29
	RubyKParserRULE_all_assignment                  = 30
	RubyKParserRULE_for_init_list                   = 31
	RubyKParserRULE_cond_expression                 = 32
	RubyKParserRULE_loop_expression                 = 33
	RubyKParserRULE_for_loop_list                   = 34
	RubyKParserRULE_statement_body                  = 35
	RubyKParserRULE_statement_expression_list       = 36
	RubyKParserRULE_assignment                      = 37
	RubyKParserRULE_dynamic_assignment              = 38
	RubyKParserRULE_int_assignment                  = 39
	RubyKParserRULE_float_assignment                = 40
	RubyKParserRULE_string_assignment               = 41
	RubyKParserRULE_initial_array_assignment        = 42
	RubyKParserRULE_array_assignment                = 43
	RubyKParserRULE_array_definition                = 44
	RubyKParserRULE_array_definition_elements       = 45
	RubyKParserRULE_array_selector                  = 46
	RubyKParserRULE_dynamic_result                  = 47
	RubyKParserRULE_dynamic_                        = 48
	RubyKParserRULE_int_result                      = 49
	RubyKParserRULE_float_result                    = 50
	RubyKParserRULE_string_result                   = 51
	RubyKParserRULE_comparison_list                 = 52
	RubyKParserRULE_comparison                      = 53
	RubyKParserRULE_comp_var                        = 54
	RubyKParserRULE_lvalue                          = 55
	RubyKParserRULE_rvalue                          = 56
	RubyKParserRULE_break_expression                = 57
	RubyKParserRULE_literal_t                       = 58
	RubyKParserRULE_float_t                         = 59
	RubyKParserRULE_int_t                           = 60
	RubyKParserRULE_bool_t                          = 61
	RubyKParserRULE_nil_t                           = 62
	RubyKParserRULE_id_                             = 63
	RubyKParserRULE_id_global                       = 64
	RubyKParserRULE_id_function                     = 65
	RubyKParserRULE_terminator                      = 66
	RubyKParserRULE_else_token                      = 67
	RubyKParserRULE_crlf                            = 68
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_program
	return p
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) Expression_list() IExpression_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(RubyKParserEOF, 0)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Program() (localctx IProgramContext) {
	this := p
	_ = this

	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, RubyKParserRULE_program)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(138)
		p.expression_list(0)
	}
	{
		p.SetState(139)
		p.Match(RubyKParserEOF)
	}

	return localctx
}

// IExpression_listContext is an interface to support dynamic dispatch.
type IExpression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_listContext differentiates from other interfaces.
	IsExpression_listContext()
}

type Expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_listContext() *Expression_listContext {
	var p = new(Expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_expression_list
	return p
}

func (*Expression_listContext) IsExpression_listContext() {}

func NewExpression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_listContext {
	var p = new(Expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_expression_list

	return p
}

func (s *Expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_listContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_listContext) Terminator() ITerminatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITerminatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITerminatorContext)
}

func (s *Expression_listContext) Expression_list() IExpression_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterExpression_list(s)
	}
}

func (s *Expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitExpression_list(s)
	}
}

func (s *Expression_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitExpression_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Expression_list() (localctx IExpression_listContext) {
	return p.expression_list(0)
}

func (p *RubyKParser) expression_list(_p int) (localctx IExpression_listContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpression_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpression_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 2
	p.EnterRecursionRule(localctx, 2, RubyKParserRULE_expression_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(146)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RubyKParserLITERAL, RubyKParserDEF, RubyKParserRETURN, RubyKParserIF, RubyKParserUNLESS, RubyKParserWHILE, RubyKParserFOR, RubyKParserTRUE, RubyKParserFALSE, RubyKParserBIT_NOT, RubyKParserNOT, RubyKParserLEFT_RBRACKET, RubyKParserNIL, RubyKParserINT, RubyKParserFLOAT, RubyKParserID, RubyKParserID_GLOBAL, RubyKParserID_FUNCTION:
		{
			p.SetState(142)
			p.Expression()
		}
		{
			p.SetState(143)
			p.terminator(0)
		}

	case RubyKParserSEMICOLON, RubyKParserCRLF:
		{
			p.SetState(145)
			p.terminator(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(154)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExpression_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_expression_list)
			p.SetState(148)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(149)
				p.Expression()
			}
			{
				p.SetState(150)
				p.terminator(0)
			}

		}
		p.SetState(156)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Function_definition() IFunction_definitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_definitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_definitionContext)
}

func (s *ExpressionContext) Function_inline_call() IFunction_inline_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_inline_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_inline_callContext)
}

func (s *ExpressionContext) If_statement() IIf_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_statementContext)
}

func (s *ExpressionContext) Unless_statement() IUnless_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnless_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnless_statementContext)
}

func (s *ExpressionContext) Rvalue() IRvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRvalueContext)
}

func (s *ExpressionContext) Return_statement() IReturn_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturn_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturn_statementContext)
}

func (s *ExpressionContext) While_statement() IWhile_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhile_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhile_statementContext)
}

func (s *ExpressionContext) For_statement() IFor_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_statementContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Expression() (localctx IExpressionContext) {
	this := p
	_ = this

	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, RubyKParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(165)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(157)
			p.Function_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(158)
			p.Function_inline_call()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(159)
			p.If_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(160)
			p.Unless_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(161)
			p.rvalue(0)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(162)
			p.Return_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(163)
			p.While_statement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(164)
			p.For_statement()
		}

	}

	return localctx
}

// IGlobal_getContext is an interface to support dynamic dispatch.
type IGlobal_getContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_name returns the var_name rule contexts.
	GetVar_name() ILvalueContext

	// GetGlobal_name returns the global_name rule contexts.
	GetGlobal_name() IId_globalContext

	// SetVar_name sets the var_name rule contexts.
	SetVar_name(ILvalueContext)

	// SetGlobal_name sets the global_name rule contexts.
	SetGlobal_name(IId_globalContext)

	// IsGlobal_getContext differentiates from other interfaces.
	IsGlobal_getContext()
}

type Global_getContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	var_name    ILvalueContext
	op          antlr.Token
	global_name IId_globalContext
}

func NewEmptyGlobal_getContext() *Global_getContext {
	var p = new(Global_getContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_global_get
	return p
}

func (*Global_getContext) IsGlobal_getContext() {}

func NewGlobal_getContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_getContext {
	var p = new(Global_getContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_global_get

	return p
}

func (s *Global_getContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_getContext) GetOp() antlr.Token { return s.op }

func (s *Global_getContext) SetOp(v antlr.Token) { s.op = v }

func (s *Global_getContext) GetVar_name() ILvalueContext { return s.var_name }

func (s *Global_getContext) GetGlobal_name() IId_globalContext { return s.global_name }

func (s *Global_getContext) SetVar_name(v ILvalueContext) { s.var_name = v }

func (s *Global_getContext) SetGlobal_name(v IId_globalContext) { s.global_name = v }

func (s *Global_getContext) Lvalue() ILvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *Global_getContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserASSIGN, 0)
}

func (s *Global_getContext) Id_global() IId_globalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_globalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_globalContext)
}

func (s *Global_getContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_getContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_getContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterGlobal_get(s)
	}
}

func (s *Global_getContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitGlobal_get(s)
	}
}

func (s *Global_getContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitGlobal_get(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Global_get() (localctx IGlobal_getContext) {
	this := p
	_ = this

	localctx = NewGlobal_getContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, RubyKParserRULE_global_get)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(167)

		var _x = p.Lvalue()

		localctx.(*Global_getContext).var_name = _x
	}
	{
		p.SetState(168)

		var _m = p.Match(RubyKParserASSIGN)

		localctx.(*Global_getContext).op = _m
	}
	{
		p.SetState(169)

		var _x = p.Id_global()

		localctx.(*Global_getContext).global_name = _x
	}

	return localctx
}

// IGlobal_setContext is an interface to support dynamic dispatch.
type IGlobal_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetGlobal_name returns the global_name rule contexts.
	GetGlobal_name() IId_globalContext

	// GetResult returns the result rule contexts.
	GetResult() IAll_resultContext

	// SetGlobal_name sets the global_name rule contexts.
	SetGlobal_name(IId_globalContext)

	// SetResult sets the result rule contexts.
	SetResult(IAll_resultContext)

	// IsGlobal_setContext differentiates from other interfaces.
	IsGlobal_setContext()
}

type Global_setContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	global_name IId_globalContext
	op          antlr.Token
	result      IAll_resultContext
}

func NewEmptyGlobal_setContext() *Global_setContext {
	var p = new(Global_setContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_global_set
	return p
}

func (*Global_setContext) IsGlobal_setContext() {}

func NewGlobal_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_setContext {
	var p = new(Global_setContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_global_set

	return p
}

func (s *Global_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_setContext) GetOp() antlr.Token { return s.op }

func (s *Global_setContext) SetOp(v antlr.Token) { s.op = v }

func (s *Global_setContext) GetGlobal_name() IId_globalContext { return s.global_name }

func (s *Global_setContext) GetResult() IAll_resultContext { return s.result }

func (s *Global_setContext) SetGlobal_name(v IId_globalContext) { s.global_name = v }

func (s *Global_setContext) SetResult(v IAll_resultContext) { s.result = v }

func (s *Global_setContext) Id_global() IId_globalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_globalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_globalContext)
}

func (s *Global_setContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserASSIGN, 0)
}

func (s *Global_setContext) All_result() IAll_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAll_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAll_resultContext)
}

func (s *Global_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterGlobal_set(s)
	}
}

func (s *Global_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitGlobal_set(s)
	}
}

func (s *Global_setContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitGlobal_set(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Global_set() (localctx IGlobal_setContext) {
	this := p
	_ = this

	localctx = NewGlobal_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, RubyKParserRULE_global_set)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(171)

		var _x = p.Id_global()

		localctx.(*Global_setContext).global_name = _x
	}
	{
		p.SetState(172)

		var _m = p.Match(RubyKParserASSIGN)

		localctx.(*Global_setContext).op = _m
	}
	{
		p.SetState(173)

		var _x = p.All_result()

		localctx.(*Global_setContext).result = _x
	}

	return localctx
}

// IGlobal_resultContext is an interface to support dynamic dispatch.
type IGlobal_resultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobal_resultContext differentiates from other interfaces.
	IsGlobal_resultContext()
}

type Global_resultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_resultContext() *Global_resultContext {
	var p = new(Global_resultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_global_result
	return p
}

func (*Global_resultContext) IsGlobal_resultContext() {}

func NewGlobal_resultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_resultContext {
	var p = new(Global_resultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_global_result

	return p
}

func (s *Global_resultContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_resultContext) Id_global() IId_globalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_globalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_globalContext)
}

func (s *Global_resultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_resultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_resultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterGlobal_result(s)
	}
}

func (s *Global_resultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitGlobal_result(s)
	}
}

func (s *Global_resultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitGlobal_result(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Global_result() (localctx IGlobal_resultContext) {
	this := p
	_ = this

	localctx = NewGlobal_resultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, RubyKParserRULE_global_result)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(175)
		p.Id_global()
	}

	return localctx
}

// IFunction_inline_callContext is an interface to support dynamic dispatch.
type IFunction_inline_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_inline_callContext differentiates from other interfaces.
	IsFunction_inline_callContext()
}

type Function_inline_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_inline_callContext() *Function_inline_callContext {
	var p = new(Function_inline_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_inline_call
	return p
}

func (*Function_inline_callContext) IsFunction_inline_callContext() {}

func NewFunction_inline_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_inline_callContext {
	var p = new(Function_inline_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_inline_call

	return p
}

func (s *Function_inline_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_inline_callContext) Function_call() IFunction_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *Function_inline_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_inline_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_inline_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_inline_call(s)
	}
}

func (s *Function_inline_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_inline_call(s)
	}
}

func (s *Function_inline_callContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_inline_call(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_inline_call() (localctx IFunction_inline_callContext) {
	this := p
	_ = this

	localctx = NewFunction_inline_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, RubyKParserRULE_function_inline_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(177)
		p.Function_call()
	}

	return localctx
}

// IFunction_definitionContext is an interface to support dynamic dispatch.
type IFunction_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definitionContext differentiates from other interfaces.
	IsFunction_definitionContext()
}

type Function_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definitionContext() *Function_definitionContext {
	var p = new(Function_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_definition
	return p
}

func (*Function_definitionContext) IsFunction_definitionContext() {}

func NewFunction_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definitionContext {
	var p = new(Function_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_definition

	return p
}

func (s *Function_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definitionContext) Function_definition_header() IFunction_definition_headerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_definition_headerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_definition_headerContext)
}

func (s *Function_definitionContext) Function_definition_body() IFunction_definition_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_definition_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_definition_bodyContext)
}

func (s *Function_definitionContext) END() antlr.TerminalNode {
	return s.GetToken(RubyKParserEND, 0)
}

func (s *Function_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_definition(s)
	}
}

func (s *Function_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_definition(s)
	}
}

func (s *Function_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_definition() (localctx IFunction_definitionContext) {
	this := p
	_ = this

	localctx = NewFunction_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, RubyKParserRULE_function_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(179)
		p.Function_definition_header()
	}
	{
		p.SetState(180)
		p.Function_definition_body()
	}
	{
		p.SetState(181)
		p.Match(RubyKParserEND)
	}

	return localctx
}

// IFunction_definition_bodyContext is an interface to support dynamic dispatch.
type IFunction_definition_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definition_bodyContext differentiates from other interfaces.
	IsFunction_definition_bodyContext()
}

type Function_definition_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definition_bodyContext() *Function_definition_bodyContext {
	var p = new(Function_definition_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_definition_body
	return p
}

func (*Function_definition_bodyContext) IsFunction_definition_bodyContext() {}

func NewFunction_definition_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definition_bodyContext {
	var p = new(Function_definition_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_definition_body

	return p
}

func (s *Function_definition_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definition_bodyContext) Expression_list() IExpression_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Function_definition_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definition_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definition_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_definition_body(s)
	}
}

func (s *Function_definition_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_definition_body(s)
	}
}

func (s *Function_definition_bodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_definition_body(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_definition_body() (localctx IFunction_definition_bodyContext) {
	this := p
	_ = this

	localctx = NewFunction_definition_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, RubyKParserRULE_function_definition_body)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(183)
		p.expression_list(0)
	}

	return localctx
}

// IFunction_definition_headerContext is an interface to support dynamic dispatch.
type IFunction_definition_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definition_headerContext differentiates from other interfaces.
	IsFunction_definition_headerContext()
}

type Function_definition_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definition_headerContext() *Function_definition_headerContext {
	var p = new(Function_definition_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_definition_header
	return p
}

func (*Function_definition_headerContext) IsFunction_definition_headerContext() {}

func NewFunction_definition_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definition_headerContext {
	var p = new(Function_definition_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_definition_header

	return p
}

func (s *Function_definition_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definition_headerContext) DEF() antlr.TerminalNode {
	return s.GetToken(RubyKParserDEF, 0)
}

func (s *Function_definition_headerContext) Function_name() IFunction_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *Function_definition_headerContext) Crlf() ICrlfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrlfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *Function_definition_headerContext) Function_definition_params() IFunction_definition_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_definition_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_definition_paramsContext)
}

func (s *Function_definition_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definition_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definition_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_definition_header(s)
	}
}

func (s *Function_definition_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_definition_header(s)
	}
}

func (s *Function_definition_headerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_definition_header(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_definition_header() (localctx IFunction_definition_headerContext) {
	this := p
	_ = this

	localctx = NewFunction_definition_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, RubyKParserRULE_function_definition_header)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(194)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(185)
			p.Match(RubyKParserDEF)
		}
		{
			p.SetState(186)
			p.Function_name()
		}
		{
			p.SetState(187)
			p.Crlf()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(189)
			p.Match(RubyKParserDEF)
		}
		{
			p.SetState(190)
			p.Function_name()
		}
		{
			p.SetState(191)
			p.Function_definition_params()
		}
		{
			p.SetState(192)
			p.Crlf()
		}

	}

	return localctx
}

// IFunction_nameContext is an interface to support dynamic dispatch.
type IFunction_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_nameContext differentiates from other interfaces.
	IsFunction_nameContext()
}

type Function_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_nameContext() *Function_nameContext {
	var p = new(Function_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_name
	return p
}

func (*Function_nameContext) IsFunction_nameContext() {}

func NewFunction_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_nameContext {
	var p = new(Function_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_name

	return p
}

func (s *Function_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_nameContext) Id_function() IId_functionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_functionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_functionContext)
}

func (s *Function_nameContext) Id_() IId_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Function_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_name(s)
	}
}

func (s *Function_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_name(s)
	}
}

func (s *Function_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_name() (localctx IFunction_nameContext) {
	this := p
	_ = this

	localctx = NewFunction_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, RubyKParserRULE_function_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(198)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RubyKParserID_FUNCTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(196)
			p.Id_function()
		}

	case RubyKParserID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(197)
			p.Id_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_definition_paramsContext is an interface to support dynamic dispatch.
type IFunction_definition_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definition_paramsContext differentiates from other interfaces.
	IsFunction_definition_paramsContext()
}

type Function_definition_paramsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definition_paramsContext() *Function_definition_paramsContext {
	var p = new(Function_definition_paramsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_definition_params
	return p
}

func (*Function_definition_paramsContext) IsFunction_definition_paramsContext() {}

func NewFunction_definition_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definition_paramsContext {
	var p = new(Function_definition_paramsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_definition_params

	return p
}

func (s *Function_definition_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definition_paramsContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserLEFT_RBRACKET, 0)
}

func (s *Function_definition_paramsContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserRIGHT_RBRACKET, 0)
}

func (s *Function_definition_paramsContext) Function_definition_params_list() IFunction_definition_params_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_definition_params_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_definition_params_listContext)
}

func (s *Function_definition_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definition_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definition_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_definition_params(s)
	}
}

func (s *Function_definition_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_definition_params(s)
	}
}

func (s *Function_definition_paramsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_definition_params(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_definition_params() (localctx IFunction_definition_paramsContext) {
	this := p
	_ = this

	localctx = NewFunction_definition_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, RubyKParserRULE_function_definition_params)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(207)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(200)
			p.Match(RubyKParserLEFT_RBRACKET)
		}
		{
			p.SetState(201)
			p.Match(RubyKParserRIGHT_RBRACKET)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(202)
			p.Match(RubyKParserLEFT_RBRACKET)
		}
		{
			p.SetState(203)
			p.function_definition_params_list(0)
		}
		{
			p.SetState(204)
			p.Match(RubyKParserRIGHT_RBRACKET)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(206)
			p.function_definition_params_list(0)
		}

	}

	return localctx
}

// IFunction_definition_params_listContext is an interface to support dynamic dispatch.
type IFunction_definition_params_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definition_params_listContext differentiates from other interfaces.
	IsFunction_definition_params_listContext()
}

type Function_definition_params_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definition_params_listContext() *Function_definition_params_listContext {
	var p = new(Function_definition_params_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_definition_params_list
	return p
}

func (*Function_definition_params_listContext) IsFunction_definition_params_listContext() {}

func NewFunction_definition_params_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definition_params_listContext {
	var p = new(Function_definition_params_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_definition_params_list

	return p
}

func (s *Function_definition_params_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definition_params_listContext) Function_definition_param_id() IFunction_definition_param_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_definition_param_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_definition_param_idContext)
}

func (s *Function_definition_params_listContext) Function_definition_params_list() IFunction_definition_params_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_definition_params_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_definition_params_listContext)
}

func (s *Function_definition_params_listContext) COMMA() antlr.TerminalNode {
	return s.GetToken(RubyKParserCOMMA, 0)
}

func (s *Function_definition_params_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definition_params_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definition_params_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_definition_params_list(s)
	}
}

func (s *Function_definition_params_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_definition_params_list(s)
	}
}

func (s *Function_definition_params_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_definition_params_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_definition_params_list() (localctx IFunction_definition_params_listContext) {
	return p.function_definition_params_list(0)
}

func (p *RubyKParser) function_definition_params_list(_p int) (localctx IFunction_definition_params_listContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewFunction_definition_params_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFunction_definition_params_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 24
	p.EnterRecursionRule(localctx, 24, RubyKParserRULE_function_definition_params_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(210)
		p.Function_definition_param_id()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(217)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFunction_definition_params_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_function_definition_params_list)
			p.SetState(212)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(213)
				p.Match(RubyKParserCOMMA)
			}
			{
				p.SetState(214)
				p.Function_definition_param_id()
			}

		}
		p.SetState(219)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}

	return localctx
}

// IFunction_definition_param_idContext is an interface to support dynamic dispatch.
type IFunction_definition_param_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definition_param_idContext differentiates from other interfaces.
	IsFunction_definition_param_idContext()
}

type Function_definition_param_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definition_param_idContext() *Function_definition_param_idContext {
	var p = new(Function_definition_param_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_definition_param_id
	return p
}

func (*Function_definition_param_idContext) IsFunction_definition_param_idContext() {}

func NewFunction_definition_param_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definition_param_idContext {
	var p = new(Function_definition_param_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_definition_param_id

	return p
}

func (s *Function_definition_param_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definition_param_idContext) Id_() IId_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Function_definition_param_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definition_param_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definition_param_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_definition_param_id(s)
	}
}

func (s *Function_definition_param_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_definition_param_id(s)
	}
}

func (s *Function_definition_param_idContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_definition_param_id(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_definition_param_id() (localctx IFunction_definition_param_idContext) {
	this := p
	_ = this

	localctx = NewFunction_definition_param_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, RubyKParserRULE_function_definition_param_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(220)
		p.Id_()
	}

	return localctx
}

// IReturn_statementContext is an interface to support dynamic dispatch.
type IReturn_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_statementContext differentiates from other interfaces.
	IsReturn_statementContext()
}

type Return_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_statementContext() *Return_statementContext {
	var p = new(Return_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_return_statement
	return p
}

func (*Return_statementContext) IsReturn_statementContext() {}

func NewReturn_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_statementContext {
	var p = new(Return_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_return_statement

	return p
}

func (s *Return_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_statementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(RubyKParserRETURN, 0)
}

func (s *Return_statementContext) All_result() IAll_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAll_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAll_resultContext)
}

func (s *Return_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterReturn_statement(s)
	}
}

func (s *Return_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitReturn_statement(s)
	}
}

func (s *Return_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitReturn_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Return_statement() (localctx IReturn_statementContext) {
	this := p
	_ = this

	localctx = NewReturn_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, RubyKParserRULE_return_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Match(RubyKParserRETURN)
	}
	{
		p.SetState(223)
		p.All_result()
	}

	return localctx
}

// IFunction_callContext is an interface to support dynamic dispatch.
type IFunction_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IFunction_nameContext

	// GetParams returns the params rule contexts.
	GetParams() IFunction_call_param_listContext

	// SetName sets the name rule contexts.
	SetName(IFunction_nameContext)

	// SetParams sets the params rule contexts.
	SetParams(IFunction_call_param_listContext)

	// IsFunction_callContext differentiates from other interfaces.
	IsFunction_callContext()
}

type Function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IFunction_nameContext
	params IFunction_call_param_listContext
}

func NewEmptyFunction_callContext() *Function_callContext {
	var p = new(Function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_call
	return p
}

func (*Function_callContext) IsFunction_callContext() {}

func NewFunction_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_callContext {
	var p = new(Function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_call

	return p
}

func (s *Function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_callContext) GetName() IFunction_nameContext { return s.name }

func (s *Function_callContext) GetParams() IFunction_call_param_listContext { return s.params }

func (s *Function_callContext) SetName(v IFunction_nameContext) { s.name = v }

func (s *Function_callContext) SetParams(v IFunction_call_param_listContext) { s.params = v }

func (s *Function_callContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserLEFT_RBRACKET, 0)
}

func (s *Function_callContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserRIGHT_RBRACKET, 0)
}

func (s *Function_callContext) Function_name() IFunction_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *Function_callContext) Function_call_param_list() IFunction_call_param_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_call_param_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_call_param_listContext)
}

func (s *Function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_call(s)
	}
}

func (s *Function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_call(s)
	}
}

func (s *Function_callContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_call(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_call() (localctx IFunction_callContext) {
	this := p
	_ = this

	localctx = NewFunction_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, RubyKParserRULE_function_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(237)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(225)

			var _x = p.Function_name()

			localctx.(*Function_callContext).name = _x
		}
		{
			p.SetState(226)
			p.Match(RubyKParserLEFT_RBRACKET)
		}
		{
			p.SetState(227)

			var _x = p.Function_call_param_list()

			localctx.(*Function_callContext).params = _x
		}
		{
			p.SetState(228)
			p.Match(RubyKParserRIGHT_RBRACKET)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(230)

			var _x = p.Function_name()

			localctx.(*Function_callContext).name = _x
		}
		{
			p.SetState(231)

			var _x = p.Function_call_param_list()

			localctx.(*Function_callContext).params = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(233)

			var _x = p.Function_name()

			localctx.(*Function_callContext).name = _x
		}
		{
			p.SetState(234)
			p.Match(RubyKParserLEFT_RBRACKET)
		}
		{
			p.SetState(235)
			p.Match(RubyKParserRIGHT_RBRACKET)
		}

	}

	return localctx
}

// IFunction_call_param_listContext is an interface to support dynamic dispatch.
type IFunction_call_param_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_call_param_listContext differentiates from other interfaces.
	IsFunction_call_param_listContext()
}

type Function_call_param_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_param_listContext() *Function_call_param_listContext {
	var p = new(Function_call_param_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_call_param_list
	return p
}

func (*Function_call_param_listContext) IsFunction_call_param_listContext() {}

func NewFunction_call_param_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_param_listContext {
	var p = new(Function_call_param_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_call_param_list

	return p
}

func (s *Function_call_param_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_param_listContext) Function_call_params() IFunction_call_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_call_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_call_paramsContext)
}

func (s *Function_call_param_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_param_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_call_param_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_call_param_list(s)
	}
}

func (s *Function_call_param_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_call_param_list(s)
	}
}

func (s *Function_call_param_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_call_param_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_call_param_list() (localctx IFunction_call_param_listContext) {
	this := p
	_ = this

	localctx = NewFunction_call_param_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, RubyKParserRULE_function_call_param_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(239)
		p.function_call_params(0)
	}

	return localctx
}

// IFunction_call_paramsContext is an interface to support dynamic dispatch.
type IFunction_call_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_call_paramsContext differentiates from other interfaces.
	IsFunction_call_paramsContext()
}

type Function_call_paramsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_paramsContext() *Function_call_paramsContext {
	var p = new(Function_call_paramsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_call_params
	return p
}

func (*Function_call_paramsContext) IsFunction_call_paramsContext() {}

func NewFunction_call_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_paramsContext {
	var p = new(Function_call_paramsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_call_params

	return p
}

func (s *Function_call_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_paramsContext) Function_param() IFunction_paramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_paramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_paramContext)
}

func (s *Function_call_paramsContext) Function_call_params() IFunction_call_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_call_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_call_paramsContext)
}

func (s *Function_call_paramsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(RubyKParserCOMMA, 0)
}

func (s *Function_call_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_call_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_call_params(s)
	}
}

func (s *Function_call_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_call_params(s)
	}
}

func (s *Function_call_paramsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_call_params(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_call_params() (localctx IFunction_call_paramsContext) {
	return p.function_call_params(0)
}

func (p *RubyKParser) function_call_params(_p int) (localctx IFunction_call_paramsContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewFunction_call_paramsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFunction_call_paramsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 34
	p.EnterRecursionRule(localctx, 34, RubyKParserRULE_function_call_params, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(242)
		p.Function_param()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFunction_call_paramsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_function_call_params)
			p.SetState(244)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(245)
				p.Match(RubyKParserCOMMA)
			}
			{
				p.SetState(246)
				p.Function_param()
			}

		}
		p.SetState(251)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())
	}

	return localctx
}

// IFunction_paramContext is an interface to support dynamic dispatch.
type IFunction_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_paramContext differentiates from other interfaces.
	IsFunction_paramContext()
}

type Function_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_paramContext() *Function_paramContext {
	var p = new(Function_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_param
	return p
}

func (*Function_paramContext) IsFunction_paramContext() {}

func NewFunction_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_paramContext {
	var p = new(Function_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_param

	return p
}

func (s *Function_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_paramContext) Function_unnamed_param() IFunction_unnamed_paramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_unnamed_paramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_unnamed_paramContext)
}

func (s *Function_paramContext) Function_named_param() IFunction_named_paramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_named_paramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_named_paramContext)
}

func (s *Function_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_param(s)
	}
}

func (s *Function_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_param(s)
	}
}

func (s *Function_paramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_param(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_param() (localctx IFunction_paramContext) {
	this := p
	_ = this

	localctx = NewFunction_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, RubyKParserRULE_function_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(254)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(252)
			p.Function_unnamed_param()
		}

	case 2:
		{
			p.SetState(253)
			p.Function_named_param()
		}

	}

	return localctx
}

// IFunction_unnamed_paramContext is an interface to support dynamic dispatch.
type IFunction_unnamed_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_unnamed_paramContext differentiates from other interfaces.
	IsFunction_unnamed_paramContext()
}

type Function_unnamed_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_unnamed_paramContext() *Function_unnamed_paramContext {
	var p = new(Function_unnamed_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_unnamed_param
	return p
}

func (*Function_unnamed_paramContext) IsFunction_unnamed_paramContext() {}

func NewFunction_unnamed_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_unnamed_paramContext {
	var p = new(Function_unnamed_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_unnamed_param

	return p
}

func (s *Function_unnamed_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_unnamed_paramContext) Int_result() IInt_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Function_unnamed_paramContext) Float_result() IFloat_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *Function_unnamed_paramContext) String_result() IString_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *Function_unnamed_paramContext) Dynamic_result() IDynamic_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamic_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *Function_unnamed_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_unnamed_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_unnamed_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_unnamed_param(s)
	}
}

func (s *Function_unnamed_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_unnamed_param(s)
	}
}

func (s *Function_unnamed_paramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_unnamed_param(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_unnamed_param() (localctx IFunction_unnamed_paramContext) {
	this := p
	_ = this

	localctx = NewFunction_unnamed_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, RubyKParserRULE_function_unnamed_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(260)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(256)
			p.int_result(0)
		}

	case 2:
		{
			p.SetState(257)
			p.float_result(0)
		}

	case 3:
		{
			p.SetState(258)
			p.string_result(0)
		}

	case 4:
		{
			p.SetState(259)
			p.dynamic_result(0)
		}

	}

	return localctx
}

// IFunction_named_paramContext is an interface to support dynamic dispatch.
type IFunction_named_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsFunction_named_paramContext differentiates from other interfaces.
	IsFunction_named_paramContext()
}

type Function_named_paramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyFunction_named_paramContext() *Function_named_paramContext {
	var p = new(Function_named_paramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_named_param
	return p
}

func (*Function_named_paramContext) IsFunction_named_paramContext() {}

func NewFunction_named_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_named_paramContext {
	var p = new(Function_named_paramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_named_param

	return p
}

func (s *Function_named_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_named_paramContext) GetOp() antlr.Token { return s.op }

func (s *Function_named_paramContext) SetOp(v antlr.Token) { s.op = v }

func (s *Function_named_paramContext) Id_() IId_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Function_named_paramContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserASSIGN, 0)
}

func (s *Function_named_paramContext) Int_result() IInt_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Function_named_paramContext) Float_result() IFloat_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *Function_named_paramContext) String_result() IString_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *Function_named_paramContext) Dynamic_result() IDynamic_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamic_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *Function_named_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_named_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_named_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_named_param(s)
	}
}

func (s *Function_named_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_named_param(s)
	}
}

func (s *Function_named_paramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_named_param(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_named_param() (localctx IFunction_named_paramContext) {
	this := p
	_ = this

	localctx = NewFunction_named_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, RubyKParserRULE_function_named_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(262)
		p.Id_()
	}
	{
		p.SetState(263)

		var _m = p.Match(RubyKParserASSIGN)

		localctx.(*Function_named_paramContext).op = _m
	}
	p.SetState(268)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(264)
			p.int_result(0)
		}

	case 2:
		{
			p.SetState(265)
			p.float_result(0)
		}

	case 3:
		{
			p.SetState(266)
			p.string_result(0)
		}

	case 4:
		{
			p.SetState(267)
			p.dynamic_result(0)
		}

	}

	return localctx
}

// IFunction_call_assignmentContext is an interface to support dynamic dispatch.
type IFunction_call_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_call_assignmentContext differentiates from other interfaces.
	IsFunction_call_assignmentContext()
}

type Function_call_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_assignmentContext() *Function_call_assignmentContext {
	var p = new(Function_call_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_function_call_assignment
	return p
}

func (*Function_call_assignmentContext) IsFunction_call_assignmentContext() {}

func NewFunction_call_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_assignmentContext {
	var p = new(Function_call_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_function_call_assignment

	return p
}

func (s *Function_call_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_assignmentContext) Function_call() IFunction_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *Function_call_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_call_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFunction_call_assignment(s)
	}
}

func (s *Function_call_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFunction_call_assignment(s)
	}
}

func (s *Function_call_assignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFunction_call_assignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Function_call_assignment() (localctx IFunction_call_assignmentContext) {
	this := p
	_ = this

	localctx = NewFunction_call_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, RubyKParserRULE_function_call_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(270)
		p.Function_call()
	}

	return localctx
}

// IAll_resultContext is an interface to support dynamic dispatch.
type IAll_resultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAll_resultContext differentiates from other interfaces.
	IsAll_resultContext()
}

type All_resultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAll_resultContext() *All_resultContext {
	var p = new(All_resultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_all_result
	return p
}

func (*All_resultContext) IsAll_resultContext() {}

func NewAll_resultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *All_resultContext {
	var p = new(All_resultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_all_result

	return p
}

func (s *All_resultContext) GetParser() antlr.Parser { return s.parser }

func (s *All_resultContext) Int_result() IInt_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *All_resultContext) Float_result() IFloat_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *All_resultContext) String_result() IString_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *All_resultContext) Dynamic_result() IDynamic_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamic_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *All_resultContext) Global_result() IGlobal_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobal_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobal_resultContext)
}

func (s *All_resultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *All_resultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *All_resultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterAll_result(s)
	}
}

func (s *All_resultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitAll_result(s)
	}
}

func (s *All_resultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitAll_result(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) All_result() (localctx IAll_resultContext) {
	this := p
	_ = this

	localctx = NewAll_resultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, RubyKParserRULE_all_result)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(277)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(272)
			p.int_result(0)
		}

	case 2:
		{
			p.SetState(273)
			p.float_result(0)
		}

	case 3:
		{
			p.SetState(274)
			p.string_result(0)
		}

	case 4:
		{
			p.SetState(275)
			p.dynamic_result(0)
		}

	case 5:
		{
			p.SetState(276)
			p.Global_result()
		}

	}

	return localctx
}

// IElsif_statementContext is an interface to support dynamic dispatch.
type IElsif_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElsif_statementContext differentiates from other interfaces.
	IsElsif_statementContext()
}

type Elsif_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElsif_statementContext() *Elsif_statementContext {
	var p = new(Elsif_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_elsif_statement
	return p
}

func (*Elsif_statementContext) IsElsif_statementContext() {}

func NewElsif_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Elsif_statementContext {
	var p = new(Elsif_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_elsif_statement

	return p
}

func (s *Elsif_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Elsif_statementContext) If_elsif_statement() IIf_elsif_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_elsif_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_elsif_statementContext)
}

func (s *Elsif_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Elsif_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Elsif_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterElsif_statement(s)
	}
}

func (s *Elsif_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitElsif_statement(s)
	}
}

func (s *Elsif_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitElsif_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Elsif_statement() (localctx IElsif_statementContext) {
	this := p
	_ = this

	localctx = NewElsif_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, RubyKParserRULE_elsif_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(279)
		p.If_elsif_statement()
	}

	return localctx
}

// IIf_elsif_statementContext is an interface to support dynamic dispatch.
type IIf_elsif_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_elsif_statementContext differentiates from other interfaces.
	IsIf_elsif_statementContext()
}

type If_elsif_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_elsif_statementContext() *If_elsif_statementContext {
	var p = new(If_elsif_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_if_elsif_statement
	return p
}

func (*If_elsif_statementContext) IsIf_elsif_statementContext() {}

func NewIf_elsif_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_elsif_statementContext {
	var p = new(If_elsif_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_if_elsif_statement

	return p
}

func (s *If_elsif_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_elsif_statementContext) ELSIF() antlr.TerminalNode {
	return s.GetToken(RubyKParserELSIF, 0)
}

func (s *If_elsif_statementContext) Cond_expression() ICond_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICond_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICond_expressionContext)
}

func (s *If_elsif_statementContext) AllCrlf() []ICrlfContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICrlfContext); ok {
			len++
		}
	}

	tst := make([]ICrlfContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICrlfContext); ok {
			tst[i] = t.(ICrlfContext)
			i++
		}
	}

	return tst
}

func (s *If_elsif_statementContext) Crlf(i int) ICrlfContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrlfContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *If_elsif_statementContext) AllStatement_body() []IStatement_bodyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatement_bodyContext); ok {
			len++
		}
	}

	tst := make([]IStatement_bodyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatement_bodyContext); ok {
			tst[i] = t.(IStatement_bodyContext)
			i++
		}
	}

	return tst
}

func (s *If_elsif_statementContext) Statement_body(i int) IStatement_bodyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatement_bodyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatement_bodyContext)
}

func (s *If_elsif_statementContext) Else_token() IElse_tokenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElse_tokenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElse_tokenContext)
}

func (s *If_elsif_statementContext) If_elsif_statement() IIf_elsif_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_elsif_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_elsif_statementContext)
}

func (s *If_elsif_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_elsif_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_elsif_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterIf_elsif_statement(s)
	}
}

func (s *If_elsif_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitIf_elsif_statement(s)
	}
}

func (s *If_elsif_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitIf_elsif_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) If_elsif_statement() (localctx IIf_elsif_statementContext) {
	this := p
	_ = this

	localctx = NewIf_elsif_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, RubyKParserRULE_if_elsif_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(281)
			p.Match(RubyKParserELSIF)
		}
		{
			p.SetState(282)
			p.Cond_expression()
		}
		{
			p.SetState(283)
			p.Crlf()
		}
		{
			p.SetState(284)
			p.Statement_body()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(286)
			p.Match(RubyKParserELSIF)
		}
		{
			p.SetState(287)
			p.Cond_expression()
		}
		{
			p.SetState(288)
			p.Crlf()
		}
		{
			p.SetState(289)
			p.Statement_body()
		}
		{
			p.SetState(290)
			p.Else_token()
		}
		{
			p.SetState(291)
			p.Crlf()
		}
		{
			p.SetState(292)
			p.Statement_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(294)
			p.Match(RubyKParserELSIF)
		}
		{
			p.SetState(295)
			p.Cond_expression()
		}
		{
			p.SetState(296)
			p.Crlf()
		}
		{
			p.SetState(297)
			p.Statement_body()
		}
		{
			p.SetState(298)
			p.If_elsif_statement()
		}

	}

	return localctx
}

// IIf_statementContext is an interface to support dynamic dispatch.
type IIf_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_statementContext differentiates from other interfaces.
	IsIf_statementContext()
}

type If_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_statementContext() *If_statementContext {
	var p = new(If_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_if_statement
	return p
}

func (*If_statementContext) IsIf_statementContext() {}

func NewIf_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_statementContext {
	var p = new(If_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_if_statement

	return p
}

func (s *If_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(RubyKParserIF, 0)
}

func (s *If_statementContext) Cond_expression() ICond_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICond_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICond_expressionContext)
}

func (s *If_statementContext) AllCrlf() []ICrlfContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICrlfContext); ok {
			len++
		}
	}

	tst := make([]ICrlfContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICrlfContext); ok {
			tst[i] = t.(ICrlfContext)
			i++
		}
	}

	return tst
}

func (s *If_statementContext) Crlf(i int) ICrlfContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrlfContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *If_statementContext) AllStatement_body() []IStatement_bodyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatement_bodyContext); ok {
			len++
		}
	}

	tst := make([]IStatement_bodyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatement_bodyContext); ok {
			tst[i] = t.(IStatement_bodyContext)
			i++
		}
	}

	return tst
}

func (s *If_statementContext) Statement_body(i int) IStatement_bodyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatement_bodyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatement_bodyContext)
}

func (s *If_statementContext) END() antlr.TerminalNode {
	return s.GetToken(RubyKParserEND, 0)
}

func (s *If_statementContext) Else_token() IElse_tokenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElse_tokenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElse_tokenContext)
}

func (s *If_statementContext) Elsif_statement() IElsif_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElsif_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElsif_statementContext)
}

func (s *If_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterIf_statement(s)
	}
}

func (s *If_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitIf_statement(s)
	}
}

func (s *If_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitIf_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) If_statement() (localctx IIf_statementContext) {
	this := p
	_ = this

	localctx = NewIf_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, RubyKParserRULE_if_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(302)
			p.Match(RubyKParserIF)
		}
		{
			p.SetState(303)
			p.Cond_expression()
		}
		{
			p.SetState(304)
			p.Crlf()
		}
		{
			p.SetState(305)
			p.Statement_body()
		}
		{
			p.SetState(306)
			p.Match(RubyKParserEND)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(308)
			p.Match(RubyKParserIF)
		}
		{
			p.SetState(309)
			p.Cond_expression()
		}
		{
			p.SetState(310)
			p.Crlf()
		}
		{
			p.SetState(311)
			p.Statement_body()
		}
		{
			p.SetState(312)
			p.Else_token()
		}
		{
			p.SetState(313)
			p.Crlf()
		}
		{
			p.SetState(314)
			p.Statement_body()
		}
		{
			p.SetState(315)
			p.Match(RubyKParserEND)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(317)
			p.Match(RubyKParserIF)
		}
		{
			p.SetState(318)
			p.Cond_expression()
		}
		{
			p.SetState(319)
			p.Crlf()
		}
		{
			p.SetState(320)
			p.Statement_body()
		}
		{
			p.SetState(321)
			p.Elsif_statement()
		}
		{
			p.SetState(322)
			p.Match(RubyKParserEND)
		}

	}

	return localctx
}

// IUnless_statementContext is an interface to support dynamic dispatch.
type IUnless_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnless_statementContext differentiates from other interfaces.
	IsUnless_statementContext()
}

type Unless_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnless_statementContext() *Unless_statementContext {
	var p = new(Unless_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_unless_statement
	return p
}

func (*Unless_statementContext) IsUnless_statementContext() {}

func NewUnless_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unless_statementContext {
	var p = new(Unless_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_unless_statement

	return p
}

func (s *Unless_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Unless_statementContext) UNLESS() antlr.TerminalNode {
	return s.GetToken(RubyKParserUNLESS, 0)
}

func (s *Unless_statementContext) Cond_expression() ICond_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICond_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICond_expressionContext)
}

func (s *Unless_statementContext) AllCrlf() []ICrlfContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICrlfContext); ok {
			len++
		}
	}

	tst := make([]ICrlfContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICrlfContext); ok {
			tst[i] = t.(ICrlfContext)
			i++
		}
	}

	return tst
}

func (s *Unless_statementContext) Crlf(i int) ICrlfContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrlfContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *Unless_statementContext) AllStatement_body() []IStatement_bodyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatement_bodyContext); ok {
			len++
		}
	}

	tst := make([]IStatement_bodyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatement_bodyContext); ok {
			tst[i] = t.(IStatement_bodyContext)
			i++
		}
	}

	return tst
}

func (s *Unless_statementContext) Statement_body(i int) IStatement_bodyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatement_bodyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatement_bodyContext)
}

func (s *Unless_statementContext) END() antlr.TerminalNode {
	return s.GetToken(RubyKParserEND, 0)
}

func (s *Unless_statementContext) Else_token() IElse_tokenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElse_tokenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElse_tokenContext)
}

func (s *Unless_statementContext) Elsif_statement() IElsif_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElsif_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElsif_statementContext)
}

func (s *Unless_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unless_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unless_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterUnless_statement(s)
	}
}

func (s *Unless_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitUnless_statement(s)
	}
}

func (s *Unless_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitUnless_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Unless_statement() (localctx IUnless_statementContext) {
	this := p
	_ = this

	localctx = NewUnless_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, RubyKParserRULE_unless_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(348)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(326)
			p.Match(RubyKParserUNLESS)
		}
		{
			p.SetState(327)
			p.Cond_expression()
		}
		{
			p.SetState(328)
			p.Crlf()
		}
		{
			p.SetState(329)
			p.Statement_body()
		}
		{
			p.SetState(330)
			p.Match(RubyKParserEND)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(332)
			p.Match(RubyKParserUNLESS)
		}
		{
			p.SetState(333)
			p.Cond_expression()
		}
		{
			p.SetState(334)
			p.Crlf()
		}
		{
			p.SetState(335)
			p.Statement_body()
		}
		{
			p.SetState(336)
			p.Else_token()
		}
		{
			p.SetState(337)
			p.Crlf()
		}
		{
			p.SetState(338)
			p.Statement_body()
		}
		{
			p.SetState(339)
			p.Match(RubyKParserEND)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(341)
			p.Match(RubyKParserUNLESS)
		}
		{
			p.SetState(342)
			p.Cond_expression()
		}
		{
			p.SetState(343)
			p.Crlf()
		}
		{
			p.SetState(344)
			p.Statement_body()
		}
		{
			p.SetState(345)
			p.Elsif_statement()
		}
		{
			p.SetState(346)
			p.Match(RubyKParserEND)
		}

	}

	return localctx
}

// IWhile_statementContext is an interface to support dynamic dispatch.
type IWhile_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhile_statementContext differentiates from other interfaces.
	IsWhile_statementContext()
}

type While_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_statementContext() *While_statementContext {
	var p = new(While_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_while_statement
	return p
}

func (*While_statementContext) IsWhile_statementContext() {}

func NewWhile_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_statementContext {
	var p = new(While_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_while_statement

	return p
}

func (s *While_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *While_statementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(RubyKParserWHILE, 0)
}

func (s *While_statementContext) Cond_expression() ICond_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICond_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICond_expressionContext)
}

func (s *While_statementContext) Crlf() ICrlfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrlfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *While_statementContext) Statement_body() IStatement_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatement_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatement_bodyContext)
}

func (s *While_statementContext) END() antlr.TerminalNode {
	return s.GetToken(RubyKParserEND, 0)
}

func (s *While_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *While_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterWhile_statement(s)
	}
}

func (s *While_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitWhile_statement(s)
	}
}

func (s *While_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitWhile_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) While_statement() (localctx IWhile_statementContext) {
	this := p
	_ = this

	localctx = NewWhile_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, RubyKParserRULE_while_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(350)
		p.Match(RubyKParserWHILE)
	}
	{
		p.SetState(351)
		p.Cond_expression()
	}
	{
		p.SetState(352)
		p.Crlf()
	}
	{
		p.SetState(353)
		p.Statement_body()
	}
	{
		p.SetState(354)
		p.Match(RubyKParserEND)
	}

	return localctx
}

// IFor_statementContext is an interface to support dynamic dispatch.
type IFor_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_statementContext differentiates from other interfaces.
	IsFor_statementContext()
}

type For_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_statementContext() *For_statementContext {
	var p = new(For_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_for_statement
	return p
}

func (*For_statementContext) IsFor_statementContext() {}

func NewFor_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_statementContext {
	var p = new(For_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_for_statement

	return p
}

func (s *For_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *For_statementContext) FOR() antlr.TerminalNode {
	return s.GetToken(RubyKParserFOR, 0)
}

func (s *For_statementContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserLEFT_RBRACKET, 0)
}

func (s *For_statementContext) Init_expression() IInit_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInit_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInit_expressionContext)
}

func (s *For_statementContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(RubyKParserSEMICOLON)
}

func (s *For_statementContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(RubyKParserSEMICOLON, i)
}

func (s *For_statementContext) Cond_expression() ICond_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICond_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICond_expressionContext)
}

func (s *For_statementContext) Loop_expression() ILoop_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoop_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoop_expressionContext)
}

func (s *For_statementContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserRIGHT_RBRACKET, 0)
}

func (s *For_statementContext) Crlf() ICrlfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrlfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *For_statementContext) Statement_body() IStatement_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatement_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatement_bodyContext)
}

func (s *For_statementContext) END() antlr.TerminalNode {
	return s.GetToken(RubyKParserEND, 0)
}

func (s *For_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFor_statement(s)
	}
}

func (s *For_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFor_statement(s)
	}
}

func (s *For_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFor_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) For_statement() (localctx IFor_statementContext) {
	this := p
	_ = this

	localctx = NewFor_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, RubyKParserRULE_for_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(378)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(356)
			p.Match(RubyKParserFOR)
		}
		{
			p.SetState(357)
			p.Match(RubyKParserLEFT_RBRACKET)
		}
		{
			p.SetState(358)
			p.Init_expression()
		}
		{
			p.SetState(359)
			p.Match(RubyKParserSEMICOLON)
		}
		{
			p.SetState(360)
			p.Cond_expression()
		}
		{
			p.SetState(361)
			p.Match(RubyKParserSEMICOLON)
		}
		{
			p.SetState(362)
			p.Loop_expression()
		}
		{
			p.SetState(363)
			p.Match(RubyKParserRIGHT_RBRACKET)
		}
		{
			p.SetState(364)
			p.Crlf()
		}
		{
			p.SetState(365)
			p.Statement_body()
		}
		{
			p.SetState(366)
			p.Match(RubyKParserEND)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(368)
			p.Match(RubyKParserFOR)
		}
		{
			p.SetState(369)
			p.Init_expression()
		}
		{
			p.SetState(370)
			p.Match(RubyKParserSEMICOLON)
		}
		{
			p.SetState(371)
			p.Cond_expression()
		}
		{
			p.SetState(372)
			p.Match(RubyKParserSEMICOLON)
		}
		{
			p.SetState(373)
			p.Loop_expression()
		}
		{
			p.SetState(374)
			p.Crlf()
		}
		{
			p.SetState(375)
			p.Statement_body()
		}
		{
			p.SetState(376)
			p.Match(RubyKParserEND)
		}

	}

	return localctx
}

// IInit_expressionContext is an interface to support dynamic dispatch.
type IInit_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_expressionContext differentiates from other interfaces.
	IsInit_expressionContext()
}

type Init_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_expressionContext() *Init_expressionContext {
	var p = new(Init_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_init_expression
	return p
}

func (*Init_expressionContext) IsInit_expressionContext() {}

func NewInit_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_expressionContext {
	var p = new(Init_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_init_expression

	return p
}

func (s *Init_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_expressionContext) For_init_list() IFor_init_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_init_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_init_listContext)
}

func (s *Init_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterInit_expression(s)
	}
}

func (s *Init_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitInit_expression(s)
	}
}

func (s *Init_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitInit_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Init_expression() (localctx IInit_expressionContext) {
	this := p
	_ = this

	localctx = NewInit_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, RubyKParserRULE_init_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(380)
		p.for_init_list(0)
	}

	return localctx
}

// IAll_assignmentContext is an interface to support dynamic dispatch.
type IAll_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAll_assignmentContext differentiates from other interfaces.
	IsAll_assignmentContext()
}

type All_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAll_assignmentContext() *All_assignmentContext {
	var p = new(All_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_all_assignment
	return p
}

func (*All_assignmentContext) IsAll_assignmentContext() {}

func NewAll_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *All_assignmentContext {
	var p = new(All_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_all_assignment

	return p
}

func (s *All_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *All_assignmentContext) Int_assignment() IInt_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_assignmentContext)
}

func (s *All_assignmentContext) Float_assignment() IFloat_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_assignmentContext)
}

func (s *All_assignmentContext) String_assignment() IString_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_assignmentContext)
}

func (s *All_assignmentContext) Dynamic_assignment() IDynamic_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamic_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamic_assignmentContext)
}

func (s *All_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *All_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *All_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterAll_assignment(s)
	}
}

func (s *All_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitAll_assignment(s)
	}
}

func (s *All_assignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitAll_assignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) All_assignment() (localctx IAll_assignmentContext) {
	this := p
	_ = this

	localctx = NewAll_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, RubyKParserRULE_all_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(386)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(382)
			p.Int_assignment()
		}

	case 2:
		{
			p.SetState(383)
			p.Float_assignment()
		}

	case 3:
		{
			p.SetState(384)
			p.String_assignment()
		}

	case 4:
		{
			p.SetState(385)
			p.Dynamic_assignment()
		}

	}

	return localctx
}

// IFor_init_listContext is an interface to support dynamic dispatch.
type IFor_init_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_init_listContext differentiates from other interfaces.
	IsFor_init_listContext()
}

type For_init_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_init_listContext() *For_init_listContext {
	var p = new(For_init_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_for_init_list
	return p
}

func (*For_init_listContext) IsFor_init_listContext() {}

func NewFor_init_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_init_listContext {
	var p = new(For_init_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_for_init_list

	return p
}

func (s *For_init_listContext) GetParser() antlr.Parser { return s.parser }

func (s *For_init_listContext) All_assignment() IAll_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAll_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAll_assignmentContext)
}

func (s *For_init_listContext) For_init_list() IFor_init_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_init_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_init_listContext)
}

func (s *For_init_listContext) COMMA() antlr.TerminalNode {
	return s.GetToken(RubyKParserCOMMA, 0)
}

func (s *For_init_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_init_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_init_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFor_init_list(s)
	}
}

func (s *For_init_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFor_init_list(s)
	}
}

func (s *For_init_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFor_init_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) For_init_list() (localctx IFor_init_listContext) {
	return p.for_init_list(0)
}

func (p *RubyKParser) for_init_list(_p int) (localctx IFor_init_listContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewFor_init_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFor_init_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 62
	p.EnterRecursionRule(localctx, 62, RubyKParserRULE_for_init_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.All_assignment()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(396)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFor_init_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_for_init_list)
			p.SetState(391)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(392)
				p.Match(RubyKParserCOMMA)
			}
			{
				p.SetState(393)
				p.All_assignment()
			}

		}
		p.SetState(398)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())
	}

	return localctx
}

// ICond_expressionContext is an interface to support dynamic dispatch.
type ICond_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCond_expressionContext differentiates from other interfaces.
	IsCond_expressionContext()
}

type Cond_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCond_expressionContext() *Cond_expressionContext {
	var p = new(Cond_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_cond_expression
	return p
}

func (*Cond_expressionContext) IsCond_expressionContext() {}

func NewCond_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cond_expressionContext {
	var p = new(Cond_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_cond_expression

	return p
}

func (s *Cond_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cond_expressionContext) Comparison_list() IComparison_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparison_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparison_listContext)
}

func (s *Cond_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cond_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cond_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterCond_expression(s)
	}
}

func (s *Cond_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitCond_expression(s)
	}
}

func (s *Cond_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitCond_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Cond_expression() (localctx ICond_expressionContext) {
	this := p
	_ = this

	localctx = NewCond_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, RubyKParserRULE_cond_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(399)
		p.Comparison_list()
	}

	return localctx
}

// ILoop_expressionContext is an interface to support dynamic dispatch.
type ILoop_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_expressionContext differentiates from other interfaces.
	IsLoop_expressionContext()
}

type Loop_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_expressionContext() *Loop_expressionContext {
	var p = new(Loop_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_loop_expression
	return p
}

func (*Loop_expressionContext) IsLoop_expressionContext() {}

func NewLoop_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_expressionContext {
	var p = new(Loop_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_loop_expression

	return p
}

func (s *Loop_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_expressionContext) For_loop_list() IFor_loop_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_loop_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_loop_listContext)
}

func (s *Loop_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterLoop_expression(s)
	}
}

func (s *Loop_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitLoop_expression(s)
	}
}

func (s *Loop_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitLoop_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Loop_expression() (localctx ILoop_expressionContext) {
	this := p
	_ = this

	localctx = NewLoop_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, RubyKParserRULE_loop_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(401)
		p.for_loop_list(0)
	}

	return localctx
}

// IFor_loop_listContext is an interface to support dynamic dispatch.
type IFor_loop_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_loop_listContext differentiates from other interfaces.
	IsFor_loop_listContext()
}

type For_loop_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_loop_listContext() *For_loop_listContext {
	var p = new(For_loop_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_for_loop_list
	return p
}

func (*For_loop_listContext) IsFor_loop_listContext() {}

func NewFor_loop_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_loop_listContext {
	var p = new(For_loop_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_for_loop_list

	return p
}

func (s *For_loop_listContext) GetParser() antlr.Parser { return s.parser }

func (s *For_loop_listContext) All_assignment() IAll_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAll_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAll_assignmentContext)
}

func (s *For_loop_listContext) For_loop_list() IFor_loop_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_loop_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_loop_listContext)
}

func (s *For_loop_listContext) COMMA() antlr.TerminalNode {
	return s.GetToken(RubyKParserCOMMA, 0)
}

func (s *For_loop_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_loop_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_loop_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFor_loop_list(s)
	}
}

func (s *For_loop_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFor_loop_list(s)
	}
}

func (s *For_loop_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFor_loop_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) For_loop_list() (localctx IFor_loop_listContext) {
	return p.for_loop_list(0)
}

func (p *RubyKParser) for_loop_list(_p int) (localctx IFor_loop_listContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewFor_loop_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFor_loop_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 68
	p.EnterRecursionRule(localctx, 68, RubyKParserRULE_for_loop_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(404)
		p.All_assignment()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFor_loop_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_for_loop_list)
			p.SetState(406)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(407)
				p.Match(RubyKParserCOMMA)
			}
			{
				p.SetState(408)
				p.All_assignment()
			}

		}
		p.SetState(413)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
	}

	return localctx
}

// IStatement_bodyContext is an interface to support dynamic dispatch.
type IStatement_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_bodyContext differentiates from other interfaces.
	IsStatement_bodyContext()
}

type Statement_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_bodyContext() *Statement_bodyContext {
	var p = new(Statement_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_statement_body
	return p
}

func (*Statement_bodyContext) IsStatement_bodyContext() {}

func NewStatement_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_bodyContext {
	var p = new(Statement_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_statement_body

	return p
}

func (s *Statement_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_bodyContext) Statement_expression_list() IStatement_expression_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatement_expression_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatement_expression_listContext)
}

func (s *Statement_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterStatement_body(s)
	}
}

func (s *Statement_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitStatement_body(s)
	}
}

func (s *Statement_bodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitStatement_body(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Statement_body() (localctx IStatement_bodyContext) {
	this := p
	_ = this

	localctx = NewStatement_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, RubyKParserRULE_statement_body)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.statement_expression_list(0)
	}

	return localctx
}

// IStatement_expression_listContext is an interface to support dynamic dispatch.
type IStatement_expression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_expression_listContext differentiates from other interfaces.
	IsStatement_expression_listContext()
}

type Statement_expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_expression_listContext() *Statement_expression_listContext {
	var p = new(Statement_expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_statement_expression_list
	return p
}

func (*Statement_expression_listContext) IsStatement_expression_listContext() {}

func NewStatement_expression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_expression_listContext {
	var p = new(Statement_expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_statement_expression_list

	return p
}

func (s *Statement_expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_expression_listContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Statement_expression_listContext) Terminator() ITerminatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITerminatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITerminatorContext)
}

func (s *Statement_expression_listContext) RETRY() antlr.TerminalNode {
	return s.GetToken(RubyKParserRETRY, 0)
}

func (s *Statement_expression_listContext) Break_expression() IBreak_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreak_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreak_expressionContext)
}

func (s *Statement_expression_listContext) Statement_expression_list() IStatement_expression_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatement_expression_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatement_expression_listContext)
}

func (s *Statement_expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterStatement_expression_list(s)
	}
}

func (s *Statement_expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitStatement_expression_list(s)
	}
}

func (s *Statement_expression_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitStatement_expression_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Statement_expression_list() (localctx IStatement_expression_listContext) {
	return p.statement_expression_list(0)
}

func (p *RubyKParser) statement_expression_list(_p int) (localctx IStatement_expression_listContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewStatement_expression_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IStatement_expression_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 72
	p.EnterRecursionRule(localctx, 72, RubyKParserRULE_statement_expression_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(425)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RubyKParserLITERAL, RubyKParserDEF, RubyKParserRETURN, RubyKParserIF, RubyKParserUNLESS, RubyKParserWHILE, RubyKParserFOR, RubyKParserTRUE, RubyKParserFALSE, RubyKParserBIT_NOT, RubyKParserNOT, RubyKParserLEFT_RBRACKET, RubyKParserNIL, RubyKParserINT, RubyKParserFLOAT, RubyKParserID, RubyKParserID_GLOBAL, RubyKParserID_FUNCTION:
		{
			p.SetState(417)
			p.Expression()
		}
		{
			p.SetState(418)
			p.terminator(0)
		}

	case RubyKParserRETRY:
		{
			p.SetState(420)
			p.Match(RubyKParserRETRY)
		}
		{
			p.SetState(421)
			p.terminator(0)
		}

	case RubyKParserBREAK:
		{
			p.SetState(422)
			p.Break_expression()
		}
		{
			p.SetState(423)
			p.terminator(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(440)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(438)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) {
			case 1:
				localctx = NewStatement_expression_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_statement_expression_list)
				p.SetState(427)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(428)
					p.Expression()
				}
				{
					p.SetState(429)
					p.terminator(0)
				}

			case 2:
				localctx = NewStatement_expression_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_statement_expression_list)
				p.SetState(431)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(432)
					p.Match(RubyKParserRETRY)
				}
				{
					p.SetState(433)
					p.terminator(0)
				}

			case 3:
				localctx = NewStatement_expression_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_statement_expression_list)
				p.SetState(434)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(435)
					p.Break_expression()
				}
				{
					p.SetState(436)
					p.terminator(0)
				}

			}

		}
		p.SetState(442)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())
	}

	return localctx
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_id returns the var_id rule contexts.
	GetVar_id() ILvalueContext

	// SetVar_id sets the var_id rule contexts.
	SetVar_id(ILvalueContext)

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	var_id ILvalueContext
	op     antlr.Token
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_assignment
	return p
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) GetOp() antlr.Token { return s.op }

func (s *AssignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *AssignmentContext) GetVar_id() ILvalueContext { return s.var_id }

func (s *AssignmentContext) SetVar_id(v ILvalueContext) { s.var_id = v }

func (s *AssignmentContext) Rvalue() IRvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRvalueContext)
}

func (s *AssignmentContext) Lvalue() ILvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *AssignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserASSIGN, 0)
}

func (s *AssignmentContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserPLUS_ASSIGN, 0)
}

func (s *AssignmentContext) MINUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserMINUS_ASSIGN, 0)
}

func (s *AssignmentContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserMUL_ASSIGN, 0)
}

func (s *AssignmentContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserDIV_ASSIGN, 0)
}

func (s *AssignmentContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserMOD_ASSIGN, 0)
}

func (s *AssignmentContext) EXP_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserEXP_ASSIGN, 0)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (s *AssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Assignment() (localctx IAssignmentContext) {
	this := p
	_ = this

	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, RubyKParserRULE_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(443)

			var _x = p.Lvalue()

			localctx.(*AssignmentContext).var_id = _x
		}
		{
			p.SetState(444)

			var _m = p.Match(RubyKParserASSIGN)

			localctx.(*AssignmentContext).op = _m
		}
		{
			p.SetState(445)
			p.rvalue(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(447)

			var _x = p.Lvalue()

			localctx.(*AssignmentContext).var_id = _x
		}
		{
			p.SetState(448)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AssignmentContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(RubyKParserPLUS_ASSIGN-32))|(1<<(RubyKParserMINUS_ASSIGN-32))|(1<<(RubyKParserMUL_ASSIGN-32))|(1<<(RubyKParserDIV_ASSIGN-32))|(1<<(RubyKParserMOD_ASSIGN-32))|(1<<(RubyKParserEXP_ASSIGN-32)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AssignmentContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(449)
			p.rvalue(0)
		}

	}

	return localctx
}

// IDynamic_assignmentContext is an interface to support dynamic dispatch.
type IDynamic_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_id returns the var_id rule contexts.
	GetVar_id() ILvalueContext

	// SetVar_id sets the var_id rule contexts.
	SetVar_id(ILvalueContext)

	// IsDynamic_assignmentContext differentiates from other interfaces.
	IsDynamic_assignmentContext()
}

type Dynamic_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	var_id ILvalueContext
	op     antlr.Token
}

func NewEmptyDynamic_assignmentContext() *Dynamic_assignmentContext {
	var p = new(Dynamic_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_dynamic_assignment
	return p
}

func (*Dynamic_assignmentContext) IsDynamic_assignmentContext() {}

func NewDynamic_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dynamic_assignmentContext {
	var p = new(Dynamic_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_dynamic_assignment

	return p
}

func (s *Dynamic_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Dynamic_assignmentContext) GetOp() antlr.Token { return s.op }

func (s *Dynamic_assignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *Dynamic_assignmentContext) GetVar_id() ILvalueContext { return s.var_id }

func (s *Dynamic_assignmentContext) SetVar_id(v ILvalueContext) { s.var_id = v }

func (s *Dynamic_assignmentContext) Dynamic_result() IDynamic_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamic_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *Dynamic_assignmentContext) Lvalue() ILvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *Dynamic_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserASSIGN, 0)
}

func (s *Dynamic_assignmentContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserPLUS_ASSIGN, 0)
}

func (s *Dynamic_assignmentContext) MINUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserMINUS_ASSIGN, 0)
}

func (s *Dynamic_assignmentContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserMUL_ASSIGN, 0)
}

func (s *Dynamic_assignmentContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserDIV_ASSIGN, 0)
}

func (s *Dynamic_assignmentContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserMOD_ASSIGN, 0)
}

func (s *Dynamic_assignmentContext) EXP_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserEXP_ASSIGN, 0)
}

func (s *Dynamic_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dynamic_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dynamic_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterDynamic_assignment(s)
	}
}

func (s *Dynamic_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitDynamic_assignment(s)
	}
}

func (s *Dynamic_assignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitDynamic_assignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Dynamic_assignment() (localctx IDynamic_assignmentContext) {
	this := p
	_ = this

	localctx = NewDynamic_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, RubyKParserRULE_dynamic_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(461)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(453)

			var _x = p.Lvalue()

			localctx.(*Dynamic_assignmentContext).var_id = _x
		}
		{
			p.SetState(454)

			var _m = p.Match(RubyKParserASSIGN)

			localctx.(*Dynamic_assignmentContext).op = _m
		}
		{
			p.SetState(455)
			p.dynamic_result(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(457)

			var _x = p.Lvalue()

			localctx.(*Dynamic_assignmentContext).var_id = _x
		}
		{
			p.SetState(458)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Dynamic_assignmentContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(RubyKParserPLUS_ASSIGN-32))|(1<<(RubyKParserMINUS_ASSIGN-32))|(1<<(RubyKParserMUL_ASSIGN-32))|(1<<(RubyKParserDIV_ASSIGN-32))|(1<<(RubyKParserMOD_ASSIGN-32))|(1<<(RubyKParserEXP_ASSIGN-32)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Dynamic_assignmentContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(459)
			p.dynamic_result(0)
		}

	}

	return localctx
}

// IInt_assignmentContext is an interface to support dynamic dispatch.
type IInt_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_id returns the var_id rule contexts.
	GetVar_id() ILvalueContext

	// SetVar_id sets the var_id rule contexts.
	SetVar_id(ILvalueContext)

	// IsInt_assignmentContext differentiates from other interfaces.
	IsInt_assignmentContext()
}

type Int_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	var_id ILvalueContext
	op     antlr.Token
}

func NewEmptyInt_assignmentContext() *Int_assignmentContext {
	var p = new(Int_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_int_assignment
	return p
}

func (*Int_assignmentContext) IsInt_assignmentContext() {}

func NewInt_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_assignmentContext {
	var p = new(Int_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_int_assignment

	return p
}

func (s *Int_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_assignmentContext) GetOp() antlr.Token { return s.op }

func (s *Int_assignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *Int_assignmentContext) GetVar_id() ILvalueContext { return s.var_id }

func (s *Int_assignmentContext) SetVar_id(v ILvalueContext) { s.var_id = v }

func (s *Int_assignmentContext) Int_result() IInt_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Int_assignmentContext) Lvalue() ILvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *Int_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserASSIGN, 0)
}

func (s *Int_assignmentContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserPLUS_ASSIGN, 0)
}

func (s *Int_assignmentContext) MINUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserMINUS_ASSIGN, 0)
}

func (s *Int_assignmentContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserMUL_ASSIGN, 0)
}

func (s *Int_assignmentContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserDIV_ASSIGN, 0)
}

func (s *Int_assignmentContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserMOD_ASSIGN, 0)
}

func (s *Int_assignmentContext) EXP_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserEXP_ASSIGN, 0)
}

func (s *Int_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterInt_assignment(s)
	}
}

func (s *Int_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitInt_assignment(s)
	}
}

func (s *Int_assignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitInt_assignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Int_assignment() (localctx IInt_assignmentContext) {
	this := p
	_ = this

	localctx = NewInt_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, RubyKParserRULE_int_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(463)

			var _x = p.Lvalue()

			localctx.(*Int_assignmentContext).var_id = _x
		}
		{
			p.SetState(464)

			var _m = p.Match(RubyKParserASSIGN)

			localctx.(*Int_assignmentContext).op = _m
		}
		{
			p.SetState(465)
			p.int_result(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(467)

			var _x = p.Lvalue()

			localctx.(*Int_assignmentContext).var_id = _x
		}
		{
			p.SetState(468)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Int_assignmentContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(RubyKParserPLUS_ASSIGN-32))|(1<<(RubyKParserMINUS_ASSIGN-32))|(1<<(RubyKParserMUL_ASSIGN-32))|(1<<(RubyKParserDIV_ASSIGN-32))|(1<<(RubyKParserMOD_ASSIGN-32))|(1<<(RubyKParserEXP_ASSIGN-32)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Int_assignmentContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(469)
			p.int_result(0)
		}

	}

	return localctx
}

// IFloat_assignmentContext is an interface to support dynamic dispatch.
type IFloat_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_id returns the var_id rule contexts.
	GetVar_id() ILvalueContext

	// SetVar_id sets the var_id rule contexts.
	SetVar_id(ILvalueContext)

	// IsFloat_assignmentContext differentiates from other interfaces.
	IsFloat_assignmentContext()
}

type Float_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	var_id ILvalueContext
	op     antlr.Token
}

func NewEmptyFloat_assignmentContext() *Float_assignmentContext {
	var p = new(Float_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_float_assignment
	return p
}

func (*Float_assignmentContext) IsFloat_assignmentContext() {}

func NewFloat_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Float_assignmentContext {
	var p = new(Float_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_float_assignment

	return p
}

func (s *Float_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Float_assignmentContext) GetOp() antlr.Token { return s.op }

func (s *Float_assignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *Float_assignmentContext) GetVar_id() ILvalueContext { return s.var_id }

func (s *Float_assignmentContext) SetVar_id(v ILvalueContext) { s.var_id = v }

func (s *Float_assignmentContext) Float_result() IFloat_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *Float_assignmentContext) Lvalue() ILvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *Float_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserASSIGN, 0)
}

func (s *Float_assignmentContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserPLUS_ASSIGN, 0)
}

func (s *Float_assignmentContext) MINUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserMINUS_ASSIGN, 0)
}

func (s *Float_assignmentContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserMUL_ASSIGN, 0)
}

func (s *Float_assignmentContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserDIV_ASSIGN, 0)
}

func (s *Float_assignmentContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserMOD_ASSIGN, 0)
}

func (s *Float_assignmentContext) EXP_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserEXP_ASSIGN, 0)
}

func (s *Float_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Float_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Float_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFloat_assignment(s)
	}
}

func (s *Float_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFloat_assignment(s)
	}
}

func (s *Float_assignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFloat_assignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Float_assignment() (localctx IFloat_assignmentContext) {
	this := p
	_ = this

	localctx = NewFloat_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, RubyKParserRULE_float_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(481)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(473)

			var _x = p.Lvalue()

			localctx.(*Float_assignmentContext).var_id = _x
		}
		{
			p.SetState(474)

			var _m = p.Match(RubyKParserASSIGN)

			localctx.(*Float_assignmentContext).op = _m
		}
		{
			p.SetState(475)
			p.float_result(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(477)

			var _x = p.Lvalue()

			localctx.(*Float_assignmentContext).var_id = _x
		}
		{
			p.SetState(478)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Float_assignmentContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(RubyKParserPLUS_ASSIGN-32))|(1<<(RubyKParserMINUS_ASSIGN-32))|(1<<(RubyKParserMUL_ASSIGN-32))|(1<<(RubyKParserDIV_ASSIGN-32))|(1<<(RubyKParserMOD_ASSIGN-32))|(1<<(RubyKParserEXP_ASSIGN-32)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Float_assignmentContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(479)
			p.float_result(0)
		}

	}

	return localctx
}

// IString_assignmentContext is an interface to support dynamic dispatch.
type IString_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_id returns the var_id rule contexts.
	GetVar_id() ILvalueContext

	// SetVar_id sets the var_id rule contexts.
	SetVar_id(ILvalueContext)

	// IsString_assignmentContext differentiates from other interfaces.
	IsString_assignmentContext()
}

type String_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	var_id ILvalueContext
	op     antlr.Token
}

func NewEmptyString_assignmentContext() *String_assignmentContext {
	var p = new(String_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_string_assignment
	return p
}

func (*String_assignmentContext) IsString_assignmentContext() {}

func NewString_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_assignmentContext {
	var p = new(String_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_string_assignment

	return p
}

func (s *String_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *String_assignmentContext) GetOp() antlr.Token { return s.op }

func (s *String_assignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *String_assignmentContext) GetVar_id() ILvalueContext { return s.var_id }

func (s *String_assignmentContext) SetVar_id(v ILvalueContext) { s.var_id = v }

func (s *String_assignmentContext) String_result() IString_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *String_assignmentContext) Lvalue() ILvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *String_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserASSIGN, 0)
}

func (s *String_assignmentContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserPLUS_ASSIGN, 0)
}

func (s *String_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterString_assignment(s)
	}
}

func (s *String_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitString_assignment(s)
	}
}

func (s *String_assignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitString_assignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) String_assignment() (localctx IString_assignmentContext) {
	this := p
	_ = this

	localctx = NewString_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, RubyKParserRULE_string_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(483)

			var _x = p.Lvalue()

			localctx.(*String_assignmentContext).var_id = _x
		}
		{
			p.SetState(484)

			var _m = p.Match(RubyKParserASSIGN)

			localctx.(*String_assignmentContext).op = _m
		}
		{
			p.SetState(485)
			p.string_result(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(487)

			var _x = p.Lvalue()

			localctx.(*String_assignmentContext).var_id = _x
		}
		{
			p.SetState(488)

			var _m = p.Match(RubyKParserPLUS_ASSIGN)

			localctx.(*String_assignmentContext).op = _m
		}
		{
			p.SetState(489)
			p.string_result(0)
		}

	}

	return localctx
}

// IInitial_array_assignmentContext is an interface to support dynamic dispatch.
type IInitial_array_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetVar_id returns the var_id rule contexts.
	GetVar_id() ILvalueContext

	// SetVar_id sets the var_id rule contexts.
	SetVar_id(ILvalueContext)

	// IsInitial_array_assignmentContext differentiates from other interfaces.
	IsInitial_array_assignmentContext()
}

type Initial_array_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	var_id ILvalueContext
	op     antlr.Token
}

func NewEmptyInitial_array_assignmentContext() *Initial_array_assignmentContext {
	var p = new(Initial_array_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_initial_array_assignment
	return p
}

func (*Initial_array_assignmentContext) IsInitial_array_assignmentContext() {}

func NewInitial_array_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Initial_array_assignmentContext {
	var p = new(Initial_array_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_initial_array_assignment

	return p
}

func (s *Initial_array_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Initial_array_assignmentContext) GetOp() antlr.Token { return s.op }

func (s *Initial_array_assignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *Initial_array_assignmentContext) GetVar_id() ILvalueContext { return s.var_id }

func (s *Initial_array_assignmentContext) SetVar_id(v ILvalueContext) { s.var_id = v }

func (s *Initial_array_assignmentContext) LEFT_SBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserLEFT_SBRACKET, 0)
}

func (s *Initial_array_assignmentContext) RIGHT_SBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserRIGHT_SBRACKET, 0)
}

func (s *Initial_array_assignmentContext) Lvalue() ILvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *Initial_array_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserASSIGN, 0)
}

func (s *Initial_array_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Initial_array_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Initial_array_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterInitial_array_assignment(s)
	}
}

func (s *Initial_array_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitInitial_array_assignment(s)
	}
}

func (s *Initial_array_assignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitInitial_array_assignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Initial_array_assignment() (localctx IInitial_array_assignmentContext) {
	this := p
	_ = this

	localctx = NewInitial_array_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, RubyKParserRULE_initial_array_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(493)

		var _x = p.Lvalue()

		localctx.(*Initial_array_assignmentContext).var_id = _x
	}
	{
		p.SetState(494)

		var _m = p.Match(RubyKParserASSIGN)

		localctx.(*Initial_array_assignmentContext).op = _m
	}
	{
		p.SetState(495)
		p.Match(RubyKParserLEFT_SBRACKET)
	}
	{
		p.SetState(496)
		p.Match(RubyKParserRIGHT_SBRACKET)
	}

	return localctx
}

// IArray_assignmentContext is an interface to support dynamic dispatch.
type IArray_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetArr_def returns the arr_def rule contexts.
	GetArr_def() IArray_selectorContext

	// GetArr_val returns the arr_val rule contexts.
	GetArr_val() IAll_resultContext

	// SetArr_def sets the arr_def rule contexts.
	SetArr_def(IArray_selectorContext)

	// SetArr_val sets the arr_val rule contexts.
	SetArr_val(IAll_resultContext)

	// IsArray_assignmentContext differentiates from other interfaces.
	IsArray_assignmentContext()
}

type Array_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser  antlr.Parser
	arr_def IArray_selectorContext
	op      antlr.Token
	arr_val IAll_resultContext
}

func NewEmptyArray_assignmentContext() *Array_assignmentContext {
	var p = new(Array_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_array_assignment
	return p
}

func (*Array_assignmentContext) IsArray_assignmentContext() {}

func NewArray_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_assignmentContext {
	var p = new(Array_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_array_assignment

	return p
}

func (s *Array_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_assignmentContext) GetOp() antlr.Token { return s.op }

func (s *Array_assignmentContext) SetOp(v antlr.Token) { s.op = v }

func (s *Array_assignmentContext) GetArr_def() IArray_selectorContext { return s.arr_def }

func (s *Array_assignmentContext) GetArr_val() IAll_resultContext { return s.arr_val }

func (s *Array_assignmentContext) SetArr_def(v IArray_selectorContext) { s.arr_def = v }

func (s *Array_assignmentContext) SetArr_val(v IAll_resultContext) { s.arr_val = v }

func (s *Array_assignmentContext) Array_selector() IArray_selectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_selectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_selectorContext)
}

func (s *Array_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(RubyKParserASSIGN, 0)
}

func (s *Array_assignmentContext) All_result() IAll_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAll_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAll_resultContext)
}

func (s *Array_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterArray_assignment(s)
	}
}

func (s *Array_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitArray_assignment(s)
	}
}

func (s *Array_assignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitArray_assignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Array_assignment() (localctx IArray_assignmentContext) {
	this := p
	_ = this

	localctx = NewArray_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, RubyKParserRULE_array_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)

		var _x = p.Array_selector()

		localctx.(*Array_assignmentContext).arr_def = _x
	}
	{
		p.SetState(499)

		var _m = p.Match(RubyKParserASSIGN)

		localctx.(*Array_assignmentContext).op = _m
	}
	{
		p.SetState(500)

		var _x = p.All_result()

		localctx.(*Array_assignmentContext).arr_val = _x
	}

	return localctx
}

// IArray_definitionContext is an interface to support dynamic dispatch.
type IArray_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_definitionContext differentiates from other interfaces.
	IsArray_definitionContext()
}

type Array_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_definitionContext() *Array_definitionContext {
	var p = new(Array_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_array_definition
	return p
}

func (*Array_definitionContext) IsArray_definitionContext() {}

func NewArray_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_definitionContext {
	var p = new(Array_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_array_definition

	return p
}

func (s *Array_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_definitionContext) LEFT_SBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserLEFT_SBRACKET, 0)
}

func (s *Array_definitionContext) Array_definition_elements() IArray_definition_elementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_definition_elementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_definition_elementsContext)
}

func (s *Array_definitionContext) RIGHT_SBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserRIGHT_SBRACKET, 0)
}

func (s *Array_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterArray_definition(s)
	}
}

func (s *Array_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitArray_definition(s)
	}
}

func (s *Array_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitArray_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Array_definition() (localctx IArray_definitionContext) {
	this := p
	_ = this

	localctx = NewArray_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, RubyKParserRULE_array_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(502)
		p.Match(RubyKParserLEFT_SBRACKET)
	}
	{
		p.SetState(503)
		p.array_definition_elements(0)
	}
	{
		p.SetState(504)
		p.Match(RubyKParserRIGHT_SBRACKET)
	}

	return localctx
}

// IArray_definition_elementsContext is an interface to support dynamic dispatch.
type IArray_definition_elementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_definition_elementsContext differentiates from other interfaces.
	IsArray_definition_elementsContext()
}

type Array_definition_elementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_definition_elementsContext() *Array_definition_elementsContext {
	var p = new(Array_definition_elementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_array_definition_elements
	return p
}

func (*Array_definition_elementsContext) IsArray_definition_elementsContext() {}

func NewArray_definition_elementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_definition_elementsContext {
	var p = new(Array_definition_elementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_array_definition_elements

	return p
}

func (s *Array_definition_elementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_definition_elementsContext) Int_result() IInt_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Array_definition_elementsContext) Dynamic_result() IDynamic_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamic_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *Array_definition_elementsContext) Array_definition_elements() IArray_definition_elementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_definition_elementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_definition_elementsContext)
}

func (s *Array_definition_elementsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(RubyKParserCOMMA, 0)
}

func (s *Array_definition_elementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_definition_elementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_definition_elementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterArray_definition_elements(s)
	}
}

func (s *Array_definition_elementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitArray_definition_elements(s)
	}
}

func (s *Array_definition_elementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitArray_definition_elements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Array_definition_elements() (localctx IArray_definition_elementsContext) {
	return p.array_definition_elements(0)
}

func (p *RubyKParser) array_definition_elements(_p int) (localctx IArray_definition_elementsContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewArray_definition_elementsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IArray_definition_elementsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 90
	p.EnterRecursionRule(localctx, 90, RubyKParserRULE_array_definition_elements, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(507)
			p.int_result(0)
		}

	case 2:
		{
			p.SetState(508)
			p.dynamic_result(0)
		}

	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewArray_definition_elementsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_array_definition_elements)
			p.SetState(511)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(512)
				p.Match(RubyKParserCOMMA)
			}
			p.SetState(515)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(513)
					p.int_result(0)
				}

			case 2:
				{
					p.SetState(514)
					p.dynamic_result(0)
				}

			}

		}
		p.SetState(521)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}

	return localctx
}

// IArray_selectorContext is an interface to support dynamic dispatch.
type IArray_selectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_selectorContext differentiates from other interfaces.
	IsArray_selectorContext()
}

type Array_selectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_selectorContext() *Array_selectorContext {
	var p = new(Array_selectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_array_selector
	return p
}

func (*Array_selectorContext) IsArray_selectorContext() {}

func NewArray_selectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_selectorContext {
	var p = new(Array_selectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_array_selector

	return p
}

func (s *Array_selectorContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_selectorContext) Id_() IId_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Array_selectorContext) LEFT_SBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserLEFT_SBRACKET, 0)
}

func (s *Array_selectorContext) RIGHT_SBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserRIGHT_SBRACKET, 0)
}

func (s *Array_selectorContext) Int_result() IInt_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Array_selectorContext) Dynamic_result() IDynamic_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamic_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *Array_selectorContext) Id_global() IId_globalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_globalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_globalContext)
}

func (s *Array_selectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_selectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_selectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterArray_selector(s)
	}
}

func (s *Array_selectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitArray_selector(s)
	}
}

func (s *Array_selectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitArray_selector(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Array_selector() (localctx IArray_selectorContext) {
	this := p
	_ = this

	localctx = NewArray_selectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, RubyKParserRULE_array_selector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(538)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RubyKParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(522)
			p.Id_()
		}
		{
			p.SetState(523)
			p.Match(RubyKParserLEFT_SBRACKET)
		}
		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(524)
				p.int_result(0)
			}

		case 2:
			{
				p.SetState(525)
				p.dynamic_result(0)
			}

		}
		{
			p.SetState(528)
			p.Match(RubyKParserRIGHT_SBRACKET)
		}

	case RubyKParserID_GLOBAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(530)
			p.Id_global()
		}
		{
			p.SetState(531)
			p.Match(RubyKParserLEFT_SBRACKET)
		}
		p.SetState(534)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(532)
				p.int_result(0)
			}

		case 2:
			{
				p.SetState(533)
				p.dynamic_result(0)
			}

		}
		{
			p.SetState(536)
			p.Match(RubyKParserRIGHT_SBRACKET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDynamic_resultContext is an interface to support dynamic dispatch.
type IDynamic_resultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsDynamic_resultContext differentiates from other interfaces.
	IsDynamic_resultContext()
}

type Dynamic_resultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyDynamic_resultContext() *Dynamic_resultContext {
	var p = new(Dynamic_resultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_dynamic_result
	return p
}

func (*Dynamic_resultContext) IsDynamic_resultContext() {}

func NewDynamic_resultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dynamic_resultContext {
	var p = new(Dynamic_resultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_dynamic_result

	return p
}

func (s *Dynamic_resultContext) GetParser() antlr.Parser { return s.parser }

func (s *Dynamic_resultContext) GetOp() antlr.Token { return s.op }

func (s *Dynamic_resultContext) SetOp(v antlr.Token) { s.op = v }

func (s *Dynamic_resultContext) Int_result() IInt_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Dynamic_resultContext) AllDynamic_result() []IDynamic_resultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDynamic_resultContext); ok {
			len++
		}
	}

	tst := make([]IDynamic_resultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDynamic_resultContext); ok {
			tst[i] = t.(IDynamic_resultContext)
			i++
		}
	}

	return tst
}

func (s *Dynamic_resultContext) Dynamic_result(i int) IDynamic_resultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamic_resultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamic_resultContext)
}

func (s *Dynamic_resultContext) MUL() antlr.TerminalNode {
	return s.GetToken(RubyKParserMUL, 0)
}

func (s *Dynamic_resultContext) DIV() antlr.TerminalNode {
	return s.GetToken(RubyKParserDIV, 0)
}

func (s *Dynamic_resultContext) MOD() antlr.TerminalNode {
	return s.GetToken(RubyKParserMOD, 0)
}

func (s *Dynamic_resultContext) Float_result() IFloat_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *Dynamic_resultContext) String_result() IString_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *Dynamic_resultContext) PLUS() antlr.TerminalNode {
	return s.GetToken(RubyKParserPLUS, 0)
}

func (s *Dynamic_resultContext) MINUS() antlr.TerminalNode {
	return s.GetToken(RubyKParserMINUS, 0)
}

func (s *Dynamic_resultContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserLEFT_RBRACKET, 0)
}

func (s *Dynamic_resultContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserRIGHT_RBRACKET, 0)
}

func (s *Dynamic_resultContext) Dynamic_() IDynamic_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamic_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamic_Context)
}

func (s *Dynamic_resultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dynamic_resultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dynamic_resultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterDynamic_result(s)
	}
}

func (s *Dynamic_resultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitDynamic_result(s)
	}
}

func (s *Dynamic_resultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitDynamic_result(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Dynamic_result() (localctx IDynamic_resultContext) {
	return p.dynamic_result(0)
}

func (p *RubyKParser) dynamic_result(_p int) (localctx IDynamic_resultContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewDynamic_resultContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDynamic_resultContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 94
	p.EnterRecursionRule(localctx, 94, RubyKParserRULE_dynamic_result, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(541)
			p.int_result(0)
		}
		{
			p.SetState(542)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Dynamic_resultContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RubyKParserMUL)|(1<<RubyKParserDIV)|(1<<RubyKParserMOD))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Dynamic_resultContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(543)
			p.dynamic_result(13)
		}

	case 2:
		{
			p.SetState(545)
			p.float_result(0)
		}
		{
			p.SetState(546)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Dynamic_resultContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RubyKParserMUL)|(1<<RubyKParserDIV)|(1<<RubyKParserMOD))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Dynamic_resultContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(547)
			p.dynamic_result(11)
		}

	case 3:
		{
			p.SetState(549)
			p.string_result(0)
		}
		{
			p.SetState(550)

			var _m = p.Match(RubyKParserMUL)

			localctx.(*Dynamic_resultContext).op = _m
		}
		{
			p.SetState(551)
			p.dynamic_result(8)
		}

	case 4:
		{
			p.SetState(553)
			p.int_result(0)
		}
		{
			p.SetState(554)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Dynamic_resultContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == RubyKParserPLUS || _la == RubyKParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Dynamic_resultContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(555)
			p.dynamic_result(6)
		}

	case 5:
		{
			p.SetState(557)
			p.float_result(0)
		}
		{
			p.SetState(558)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Dynamic_resultContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == RubyKParserPLUS || _la == RubyKParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Dynamic_resultContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(559)
			p.dynamic_result(4)
		}

	case 6:
		{
			p.SetState(561)
			p.Match(RubyKParserLEFT_RBRACKET)
		}
		{
			p.SetState(562)
			p.dynamic_result(0)
		}
		{
			p.SetState(563)
			p.Match(RubyKParserRIGHT_RBRACKET)
		}

	case 7:
		{
			p.SetState(565)
			p.Dynamic_()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(591)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(589)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
			case 1:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_dynamic_result)
				p.SetState(568)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(569)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Dynamic_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RubyKParserMUL)|(1<<RubyKParserDIV)|(1<<RubyKParserMOD))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Dynamic_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(570)
					p.dynamic_result(11)
				}

			case 2:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_dynamic_result)
				p.SetState(571)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(572)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Dynamic_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == RubyKParserPLUS || _la == RubyKParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Dynamic_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(573)
					p.dynamic_result(4)
				}

			case 3:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_dynamic_result)
				p.SetState(574)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(575)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Dynamic_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RubyKParserMUL)|(1<<RubyKParserDIV)|(1<<RubyKParserMOD))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Dynamic_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(576)
					p.int_result(0)
				}

			case 4:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_dynamic_result)
				p.SetState(577)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(578)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Dynamic_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RubyKParserMUL)|(1<<RubyKParserDIV)|(1<<RubyKParserMOD))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Dynamic_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(579)
					p.float_result(0)
				}

			case 5:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_dynamic_result)
				p.SetState(580)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(581)

					var _m = p.Match(RubyKParserMUL)

					localctx.(*Dynamic_resultContext).op = _m
				}
				{
					p.SetState(582)
					p.string_result(0)
				}

			case 6:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_dynamic_result)
				p.SetState(583)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(584)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Dynamic_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == RubyKParserPLUS || _la == RubyKParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Dynamic_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(585)
					p.int_result(0)
				}

			case 7:
				localctx = NewDynamic_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_dynamic_result)
				p.SetState(586)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(587)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Dynamic_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == RubyKParserPLUS || _la == RubyKParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Dynamic_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(588)
					p.float_result(0)
				}

			}

		}
		p.SetState(593)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())
	}

	return localctx
}

// IDynamic_Context is an interface to support dynamic dispatch.
type IDynamic_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDynamic_Context differentiates from other interfaces.
	IsDynamic_Context()
}

type Dynamic_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDynamic_Context() *Dynamic_Context {
	var p = new(Dynamic_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_dynamic_
	return p
}

func (*Dynamic_Context) IsDynamic_Context() {}

func NewDynamic_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dynamic_Context {
	var p = new(Dynamic_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_dynamic_

	return p
}

func (s *Dynamic_Context) GetParser() antlr.Parser { return s.parser }

func (s *Dynamic_Context) Id_() IId_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Dynamic_Context) Function_call_assignment() IFunction_call_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_call_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_call_assignmentContext)
}

func (s *Dynamic_Context) Array_selector() IArray_selectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_selectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_selectorContext)
}

func (s *Dynamic_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dynamic_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dynamic_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterDynamic_(s)
	}
}

func (s *Dynamic_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitDynamic_(s)
	}
}

func (s *Dynamic_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitDynamic_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Dynamic_() (localctx IDynamic_Context) {
	this := p
	_ = this

	localctx = NewDynamic_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, RubyKParserRULE_dynamic_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(594)
			p.Id_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(595)
			p.Function_call_assignment()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(596)
			p.Array_selector()
		}

	}

	return localctx
}

// IInt_resultContext is an interface to support dynamic dispatch.
type IInt_resultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsInt_resultContext differentiates from other interfaces.
	IsInt_resultContext()
}

type Int_resultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyInt_resultContext() *Int_resultContext {
	var p = new(Int_resultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_int_result
	return p
}

func (*Int_resultContext) IsInt_resultContext() {}

func NewInt_resultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_resultContext {
	var p = new(Int_resultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_int_result

	return p
}

func (s *Int_resultContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_resultContext) GetOp() antlr.Token { return s.op }

func (s *Int_resultContext) SetOp(v antlr.Token) { s.op = v }

func (s *Int_resultContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserLEFT_RBRACKET, 0)
}

func (s *Int_resultContext) AllInt_result() []IInt_resultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInt_resultContext); ok {
			len++
		}
	}

	tst := make([]IInt_resultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInt_resultContext); ok {
			tst[i] = t.(IInt_resultContext)
			i++
		}
	}

	return tst
}

func (s *Int_resultContext) Int_result(i int) IInt_resultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_resultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Int_resultContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserRIGHT_RBRACKET, 0)
}

func (s *Int_resultContext) Int_t() IInt_tContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_tContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_tContext)
}

func (s *Int_resultContext) MUL() antlr.TerminalNode {
	return s.GetToken(RubyKParserMUL, 0)
}

func (s *Int_resultContext) DIV() antlr.TerminalNode {
	return s.GetToken(RubyKParserDIV, 0)
}

func (s *Int_resultContext) MOD() antlr.TerminalNode {
	return s.GetToken(RubyKParserMOD, 0)
}

func (s *Int_resultContext) PLUS() antlr.TerminalNode {
	return s.GetToken(RubyKParserPLUS, 0)
}

func (s *Int_resultContext) MINUS() antlr.TerminalNode {
	return s.GetToken(RubyKParserMINUS, 0)
}

func (s *Int_resultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_resultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int_resultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterInt_result(s)
	}
}

func (s *Int_resultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitInt_result(s)
	}
}

func (s *Int_resultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitInt_result(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Int_result() (localctx IInt_resultContext) {
	return p.int_result(0)
}

func (p *RubyKParser) int_result(_p int) (localctx IInt_resultContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewInt_resultContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInt_resultContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 98
	p.EnterRecursionRule(localctx, 98, RubyKParserRULE_int_result, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(605)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RubyKParserLEFT_RBRACKET:
		{
			p.SetState(600)
			p.Match(RubyKParserLEFT_RBRACKET)
		}
		{
			p.SetState(601)
			p.int_result(0)
		}
		{
			p.SetState(602)
			p.Match(RubyKParserRIGHT_RBRACKET)
		}

	case RubyKParserINT:
		{
			p.SetState(604)
			p.Int_t()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(615)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(613)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
			case 1:
				localctx = NewInt_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_int_result)
				p.SetState(607)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(608)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Int_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RubyKParserMUL)|(1<<RubyKParserDIV)|(1<<RubyKParserMOD))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Int_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(609)
					p.int_result(5)
				}

			case 2:
				localctx = NewInt_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_int_result)
				p.SetState(610)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(611)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Int_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == RubyKParserPLUS || _la == RubyKParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Int_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(612)
					p.int_result(4)
				}

			}

		}
		p.SetState(617)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())
	}

	return localctx
}

// IFloat_resultContext is an interface to support dynamic dispatch.
type IFloat_resultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsFloat_resultContext differentiates from other interfaces.
	IsFloat_resultContext()
}

type Float_resultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyFloat_resultContext() *Float_resultContext {
	var p = new(Float_resultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_float_result
	return p
}

func (*Float_resultContext) IsFloat_resultContext() {}

func NewFloat_resultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Float_resultContext {
	var p = new(Float_resultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_float_result

	return p
}

func (s *Float_resultContext) GetParser() antlr.Parser { return s.parser }

func (s *Float_resultContext) GetOp() antlr.Token { return s.op }

func (s *Float_resultContext) SetOp(v antlr.Token) { s.op = v }

func (s *Float_resultContext) Int_result() IInt_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *Float_resultContext) AllFloat_result() []IFloat_resultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFloat_resultContext); ok {
			len++
		}
	}

	tst := make([]IFloat_resultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFloat_resultContext); ok {
			tst[i] = t.(IFloat_resultContext)
			i++
		}
	}

	return tst
}

func (s *Float_resultContext) Float_result(i int) IFloat_resultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_resultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *Float_resultContext) MUL() antlr.TerminalNode {
	return s.GetToken(RubyKParserMUL, 0)
}

func (s *Float_resultContext) DIV() antlr.TerminalNode {
	return s.GetToken(RubyKParserDIV, 0)
}

func (s *Float_resultContext) MOD() antlr.TerminalNode {
	return s.GetToken(RubyKParserMOD, 0)
}

func (s *Float_resultContext) PLUS() antlr.TerminalNode {
	return s.GetToken(RubyKParserPLUS, 0)
}

func (s *Float_resultContext) MINUS() antlr.TerminalNode {
	return s.GetToken(RubyKParserMINUS, 0)
}

func (s *Float_resultContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserLEFT_RBRACKET, 0)
}

func (s *Float_resultContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserRIGHT_RBRACKET, 0)
}

func (s *Float_resultContext) Float_t() IFloat_tContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_tContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_tContext)
}

func (s *Float_resultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Float_resultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Float_resultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFloat_result(s)
	}
}

func (s *Float_resultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFloat_result(s)
	}
}

func (s *Float_resultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFloat_result(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Float_result() (localctx IFloat_resultContext) {
	return p.float_result(0)
}

func (p *RubyKParser) float_result(_p int) (localctx IFloat_resultContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewFloat_resultContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFloat_resultContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 100
	p.EnterRecursionRule(localctx, 100, RubyKParserRULE_float_result, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(619)
			p.int_result(0)
		}
		{
			p.SetState(620)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Float_resultContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RubyKParserMUL)|(1<<RubyKParserDIV)|(1<<RubyKParserMOD))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Float_resultContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(621)
			p.float_result(7)
		}

	case 2:
		{
			p.SetState(623)
			p.int_result(0)
		}
		{
			p.SetState(624)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Float_resultContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == RubyKParserPLUS || _la == RubyKParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Float_resultContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(625)
			p.float_result(4)
		}

	case 3:
		{
			p.SetState(627)
			p.Match(RubyKParserLEFT_RBRACKET)
		}
		{
			p.SetState(628)
			p.float_result(0)
		}
		{
			p.SetState(629)
			p.Match(RubyKParserRIGHT_RBRACKET)
		}

	case 4:
		{
			p.SetState(631)
			p.Float_t()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(646)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
			case 1:
				localctx = NewFloat_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_float_result)
				p.SetState(634)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(635)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Float_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RubyKParserMUL)|(1<<RubyKParserDIV)|(1<<RubyKParserMOD))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Float_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(636)
					p.float_result(9)
				}

			case 2:
				localctx = NewFloat_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_float_result)
				p.SetState(637)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(638)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Float_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == RubyKParserPLUS || _la == RubyKParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Float_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(639)
					p.float_result(6)
				}

			case 3:
				localctx = NewFloat_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_float_result)
				p.SetState(640)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(641)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Float_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RubyKParserMUL)|(1<<RubyKParserDIV)|(1<<RubyKParserMOD))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Float_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(642)
					p.int_result(0)
				}

			case 4:
				localctx = NewFloat_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_float_result)
				p.SetState(643)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(644)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*Float_resultContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == RubyKParserPLUS || _la == RubyKParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*Float_resultContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(645)
					p.int_result(0)
				}

			}

		}
		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())
	}

	return localctx
}

// IString_resultContext is an interface to support dynamic dispatch.
type IString_resultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsString_resultContext differentiates from other interfaces.
	IsString_resultContext()
}

type String_resultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyString_resultContext() *String_resultContext {
	var p = new(String_resultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_string_result
	return p
}

func (*String_resultContext) IsString_resultContext() {}

func NewString_resultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_resultContext {
	var p = new(String_resultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_string_result

	return p
}

func (s *String_resultContext) GetParser() antlr.Parser { return s.parser }

func (s *String_resultContext) GetOp() antlr.Token { return s.op }

func (s *String_resultContext) SetOp(v antlr.Token) { s.op = v }

func (s *String_resultContext) Int_result() IInt_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *String_resultContext) AllString_result() []IString_resultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IString_resultContext); ok {
			len++
		}
	}

	tst := make([]IString_resultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IString_resultContext); ok {
			tst[i] = t.(IString_resultContext)
			i++
		}
	}

	return tst
}

func (s *String_resultContext) String_result(i int) IString_resultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_resultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *String_resultContext) MUL() antlr.TerminalNode {
	return s.GetToken(RubyKParserMUL, 0)
}

func (s *String_resultContext) Literal_t() ILiteral_tContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_tContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_tContext)
}

func (s *String_resultContext) PLUS() antlr.TerminalNode {
	return s.GetToken(RubyKParserPLUS, 0)
}

func (s *String_resultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_resultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_resultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterString_result(s)
	}
}

func (s *String_resultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitString_result(s)
	}
}

func (s *String_resultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitString_result(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) String_result() (localctx IString_resultContext) {
	return p.string_result(0)
}

func (p *RubyKParser) string_result(_p int) (localctx IString_resultContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewString_resultContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IString_resultContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 102
	p.EnterRecursionRule(localctx, 102, RubyKParserRULE_string_result, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(657)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RubyKParserLEFT_RBRACKET, RubyKParserINT:
		{
			p.SetState(652)
			p.int_result(0)
		}
		{
			p.SetState(653)

			var _m = p.Match(RubyKParserMUL)

			localctx.(*String_resultContext).op = _m
		}
		{
			p.SetState(654)
			p.string_result(3)
		}

	case RubyKParserLITERAL:
		{
			p.SetState(656)
			p.Literal_t()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(667)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(665)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
			case 1:
				localctx = NewString_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_string_result)
				p.SetState(659)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(660)

					var _m = p.Match(RubyKParserPLUS)

					localctx.(*String_resultContext).op = _m
				}
				{
					p.SetState(661)
					p.string_result(3)
				}

			case 2:
				localctx = NewString_resultContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_string_result)
				p.SetState(662)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(663)

					var _m = p.Match(RubyKParserMUL)

					localctx.(*String_resultContext).op = _m
				}
				{
					p.SetState(664)
					p.int_result(0)
				}

			}

		}
		p.SetState(669)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())
	}

	return localctx
}

// IComparison_listContext is an interface to support dynamic dispatch.
type IComparison_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IComparisonContext

	// GetRight returns the right rule contexts.
	GetRight() IComparison_listContext

	// SetLeft sets the left rule contexts.
	SetLeft(IComparisonContext)

	// SetRight sets the right rule contexts.
	SetRight(IComparison_listContext)

	// IsComparison_listContext differentiates from other interfaces.
	IsComparison_listContext()
}

type Comparison_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IComparisonContext
	op     antlr.Token
	right  IComparison_listContext
}

func NewEmptyComparison_listContext() *Comparison_listContext {
	var p = new(Comparison_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_comparison_list
	return p
}

func (*Comparison_listContext) IsComparison_listContext() {}

func NewComparison_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comparison_listContext {
	var p = new(Comparison_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_comparison_list

	return p
}

func (s *Comparison_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Comparison_listContext) GetOp() antlr.Token { return s.op }

func (s *Comparison_listContext) SetOp(v antlr.Token) { s.op = v }

func (s *Comparison_listContext) GetLeft() IComparisonContext { return s.left }

func (s *Comparison_listContext) GetRight() IComparison_listContext { return s.right }

func (s *Comparison_listContext) SetLeft(v IComparisonContext) { s.left = v }

func (s *Comparison_listContext) SetRight(v IComparison_listContext) { s.right = v }

func (s *Comparison_listContext) Comparison() IComparisonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *Comparison_listContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(RubyKParserBIT_AND, 0)
}

func (s *Comparison_listContext) Comparison_list() IComparison_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparison_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparison_listContext)
}

func (s *Comparison_listContext) AND() antlr.TerminalNode {
	return s.GetToken(RubyKParserAND, 0)
}

func (s *Comparison_listContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(RubyKParserBIT_OR, 0)
}

func (s *Comparison_listContext) OR() antlr.TerminalNode {
	return s.GetToken(RubyKParserOR, 0)
}

func (s *Comparison_listContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserLEFT_RBRACKET, 0)
}

func (s *Comparison_listContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserRIGHT_RBRACKET, 0)
}

func (s *Comparison_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comparison_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comparison_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterComparison_list(s)
	}
}

func (s *Comparison_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitComparison_list(s)
	}
}

func (s *Comparison_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitComparison_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Comparison_list() (localctx IComparison_listContext) {
	this := p
	_ = this

	localctx = NewComparison_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, RubyKParserRULE_comparison_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(670)

			var _x = p.Comparison()

			localctx.(*Comparison_listContext).left = _x
		}
		{
			p.SetState(671)

			var _m = p.Match(RubyKParserBIT_AND)

			localctx.(*Comparison_listContext).op = _m
		}
		{
			p.SetState(672)

			var _x = p.Comparison_list()

			localctx.(*Comparison_listContext).right = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(674)

			var _x = p.Comparison()

			localctx.(*Comparison_listContext).left = _x
		}
		{
			p.SetState(675)

			var _m = p.Match(RubyKParserAND)

			localctx.(*Comparison_listContext).op = _m
		}
		{
			p.SetState(676)

			var _x = p.Comparison_list()

			localctx.(*Comparison_listContext).right = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(678)

			var _x = p.Comparison()

			localctx.(*Comparison_listContext).left = _x
		}
		{
			p.SetState(679)

			var _m = p.Match(RubyKParserBIT_OR)

			localctx.(*Comparison_listContext).op = _m
		}
		{
			p.SetState(680)

			var _x = p.Comparison_list()

			localctx.(*Comparison_listContext).right = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(682)

			var _x = p.Comparison()

			localctx.(*Comparison_listContext).left = _x
		}
		{
			p.SetState(683)

			var _m = p.Match(RubyKParserOR)

			localctx.(*Comparison_listContext).op = _m
		}
		{
			p.SetState(684)

			var _x = p.Comparison_list()

			localctx.(*Comparison_listContext).right = _x
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(686)
			p.Match(RubyKParserLEFT_RBRACKET)
		}
		{
			p.SetState(687)
			p.Comparison_list()
		}
		{
			p.SetState(688)
			p.Match(RubyKParserRIGHT_RBRACKET)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(690)
			p.Comparison()
		}

	}

	return localctx
}

// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IComp_varContext

	// GetRight returns the right rule contexts.
	GetRight() IComp_varContext

	// SetLeft sets the left rule contexts.
	SetLeft(IComp_varContext)

	// SetRight sets the right rule contexts.
	SetRight(IComp_varContext)

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IComp_varContext
	op     antlr.Token
	right  IComp_varContext
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_comparison
	return p
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) GetOp() antlr.Token { return s.op }

func (s *ComparisonContext) SetOp(v antlr.Token) { s.op = v }

func (s *ComparisonContext) GetLeft() IComp_varContext { return s.left }

func (s *ComparisonContext) GetRight() IComp_varContext { return s.right }

func (s *ComparisonContext) SetLeft(v IComp_varContext) { s.left = v }

func (s *ComparisonContext) SetRight(v IComp_varContext) { s.right = v }

func (s *ComparisonContext) AllComp_var() []IComp_varContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComp_varContext); ok {
			len++
		}
	}

	tst := make([]IComp_varContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComp_varContext); ok {
			tst[i] = t.(IComp_varContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) Comp_var(i int) IComp_varContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_varContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_varContext)
}

func (s *ComparisonContext) LESS() antlr.TerminalNode {
	return s.GetToken(RubyKParserLESS, 0)
}

func (s *ComparisonContext) GREATER() antlr.TerminalNode {
	return s.GetToken(RubyKParserGREATER, 0)
}

func (s *ComparisonContext) LESS_EQUAL() antlr.TerminalNode {
	return s.GetToken(RubyKParserLESS_EQUAL, 0)
}

func (s *ComparisonContext) GREATER_EQUAL() antlr.TerminalNode {
	return s.GetToken(RubyKParserGREATER_EQUAL, 0)
}

func (s *ComparisonContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(RubyKParserEQUAL, 0)
}

func (s *ComparisonContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(RubyKParserNOT_EQUAL, 0)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Comparison() (localctx IComparisonContext) {
	this := p
	_ = this

	localctx = NewComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, RubyKParserRULE_comparison)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(693)

			var _x = p.Comp_var()

			localctx.(*ComparisonContext).left = _x
		}
		{
			p.SetState(694)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ComparisonContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RubyKParserGREATER)|(1<<RubyKParserLESS)|(1<<RubyKParserLESS_EQUAL)|(1<<RubyKParserGREATER_EQUAL))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ComparisonContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(695)

			var _x = p.Comp_var()

			localctx.(*ComparisonContext).right = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(697)

			var _x = p.Comp_var()

			localctx.(*ComparisonContext).left = _x
		}
		{
			p.SetState(698)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ComparisonContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == RubyKParserEQUAL || _la == RubyKParserNOT_EQUAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ComparisonContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(699)

			var _x = p.Comp_var()

			localctx.(*ComparisonContext).right = _x
		}

	}

	return localctx
}

// IComp_varContext is an interface to support dynamic dispatch.
type IComp_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_varContext differentiates from other interfaces.
	IsComp_varContext()
}

type Comp_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_varContext() *Comp_varContext {
	var p = new(Comp_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_comp_var
	return p
}

func (*Comp_varContext) IsComp_varContext() {}

func NewComp_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_varContext {
	var p = new(Comp_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_comp_var

	return p
}

func (s *Comp_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_varContext) All_result() IAll_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAll_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAll_resultContext)
}

func (s *Comp_varContext) Array_selector() IArray_selectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_selectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_selectorContext)
}

func (s *Comp_varContext) Id_() IId_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *Comp_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterComp_var(s)
	}
}

func (s *Comp_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitComp_var(s)
	}
}

func (s *Comp_varContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitComp_var(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Comp_var() (localctx IComp_varContext) {
	this := p
	_ = this

	localctx = NewComp_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, RubyKParserRULE_comp_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(706)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(703)
			p.All_result()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(704)
			p.Array_selector()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(705)
			p.Id_()
		}

	}

	return localctx
}

// ILvalueContext is an interface to support dynamic dispatch.
type ILvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLvalueContext differentiates from other interfaces.
	IsLvalueContext()
}

type LvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLvalueContext() *LvalueContext {
	var p = new(LvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_lvalue
	return p
}

func (*LvalueContext) IsLvalueContext() {}

func NewLvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LvalueContext {
	var p = new(LvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_lvalue

	return p
}

func (s *LvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *LvalueContext) Id_() IId_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IId_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IId_Context)
}

func (s *LvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterLvalue(s)
	}
}

func (s *LvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitLvalue(s)
	}
}

func (s *LvalueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitLvalue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Lvalue() (localctx ILvalueContext) {
	this := p
	_ = this

	localctx = NewLvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, RubyKParserRULE_lvalue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(708)
		p.Id_()
	}

	return localctx
}

// IRvalueContext is an interface to support dynamic dispatch.
type IRvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRvalueContext differentiates from other interfaces.
	IsRvalueContext()
}

type RvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRvalueContext() *RvalueContext {
	var p = new(RvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_rvalue
	return p
}

func (*RvalueContext) IsRvalueContext() {}

func NewRvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RvalueContext {
	var p = new(RvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_rvalue

	return p
}

func (s *RvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *RvalueContext) Lvalue() ILvalueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILvalueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILvalueContext)
}

func (s *RvalueContext) Initial_array_assignment() IInitial_array_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitial_array_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitial_array_assignmentContext)
}

func (s *RvalueContext) Array_assignment() IArray_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_assignmentContext)
}

func (s *RvalueContext) Int_result() IInt_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_resultContext)
}

func (s *RvalueContext) Float_result() IFloat_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_resultContext)
}

func (s *RvalueContext) String_result() IString_resultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_resultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_resultContext)
}

func (s *RvalueContext) Global_set() IGlobal_setContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobal_setContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobal_setContext)
}

func (s *RvalueContext) Global_get() IGlobal_getContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobal_getContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobal_getContext)
}

func (s *RvalueContext) Dynamic_assignment() IDynamic_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamic_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamic_assignmentContext)
}

func (s *RvalueContext) String_assignment() IString_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_assignmentContext)
}

func (s *RvalueContext) Float_assignment() IFloat_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_assignmentContext)
}

func (s *RvalueContext) Int_assignment() IInt_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_assignmentContext)
}

func (s *RvalueContext) Assignment() IAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *RvalueContext) Function_call() IFunction_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *RvalueContext) Literal_t() ILiteral_tContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_tContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_tContext)
}

func (s *RvalueContext) Bool_t() IBool_tContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_tContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_tContext)
}

func (s *RvalueContext) Float_t() IFloat_tContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_tContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_tContext)
}

func (s *RvalueContext) Int_t() IInt_tContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_tContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_tContext)
}

func (s *RvalueContext) Nil_t() INil_tContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INil_tContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INil_tContext)
}

func (s *RvalueContext) AllRvalue() []IRvalueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRvalueContext); ok {
			len++
		}
	}

	tst := make([]IRvalueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRvalueContext); ok {
			tst[i] = t.(IRvalueContext)
			i++
		}
	}

	return tst
}

func (s *RvalueContext) Rvalue(i int) IRvalueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRvalueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRvalueContext)
}

func (s *RvalueContext) NOT() antlr.TerminalNode {
	return s.GetToken(RubyKParserNOT, 0)
}

func (s *RvalueContext) BIT_NOT() antlr.TerminalNode {
	return s.GetToken(RubyKParserBIT_NOT, 0)
}

func (s *RvalueContext) LEFT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserLEFT_RBRACKET, 0)
}

func (s *RvalueContext) RIGHT_RBRACKET() antlr.TerminalNode {
	return s.GetToken(RubyKParserRIGHT_RBRACKET, 0)
}

func (s *RvalueContext) EXP() antlr.TerminalNode {
	return s.GetToken(RubyKParserEXP, 0)
}

func (s *RvalueContext) MUL() antlr.TerminalNode {
	return s.GetToken(RubyKParserMUL, 0)
}

func (s *RvalueContext) DIV() antlr.TerminalNode {
	return s.GetToken(RubyKParserDIV, 0)
}

func (s *RvalueContext) MOD() antlr.TerminalNode {
	return s.GetToken(RubyKParserMOD, 0)
}

func (s *RvalueContext) PLUS() antlr.TerminalNode {
	return s.GetToken(RubyKParserPLUS, 0)
}

func (s *RvalueContext) MINUS() antlr.TerminalNode {
	return s.GetToken(RubyKParserMINUS, 0)
}

func (s *RvalueContext) BIT_SHL() antlr.TerminalNode {
	return s.GetToken(RubyKParserBIT_SHL, 0)
}

func (s *RvalueContext) BIT_SHR() antlr.TerminalNode {
	return s.GetToken(RubyKParserBIT_SHR, 0)
}

func (s *RvalueContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(RubyKParserBIT_AND, 0)
}

func (s *RvalueContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(RubyKParserBIT_OR, 0)
}

func (s *RvalueContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(RubyKParserBIT_XOR, 0)
}

func (s *RvalueContext) LESS() antlr.TerminalNode {
	return s.GetToken(RubyKParserLESS, 0)
}

func (s *RvalueContext) GREATER() antlr.TerminalNode {
	return s.GetToken(RubyKParserGREATER, 0)
}

func (s *RvalueContext) LESS_EQUAL() antlr.TerminalNode {
	return s.GetToken(RubyKParserLESS_EQUAL, 0)
}

func (s *RvalueContext) GREATER_EQUAL() antlr.TerminalNode {
	return s.GetToken(RubyKParserGREATER_EQUAL, 0)
}

func (s *RvalueContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(RubyKParserEQUAL, 0)
}

func (s *RvalueContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(RubyKParserNOT_EQUAL, 0)
}

func (s *RvalueContext) OR() antlr.TerminalNode {
	return s.GetToken(RubyKParserOR, 0)
}

func (s *RvalueContext) AND() antlr.TerminalNode {
	return s.GetToken(RubyKParserAND, 0)
}

func (s *RvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterRvalue(s)
	}
}

func (s *RvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitRvalue(s)
	}
}

func (s *RvalueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitRvalue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Rvalue() (localctx IRvalueContext) {
	return p.rvalue(0)
}

func (p *RubyKParser) rvalue(_p int) (localctx IRvalueContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRvalueContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRvalueContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 112
	p.EnterRecursionRule(localctx, 112, RubyKParserRULE_rvalue, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(711)
			p.Lvalue()
		}

	case 2:
		{
			p.SetState(712)
			p.Initial_array_assignment()
		}

	case 3:
		{
			p.SetState(713)
			p.Array_assignment()
		}

	case 4:
		{
			p.SetState(714)
			p.int_result(0)
		}

	case 5:
		{
			p.SetState(715)
			p.float_result(0)
		}

	case 6:
		{
			p.SetState(716)
			p.string_result(0)
		}

	case 7:
		{
			p.SetState(717)
			p.Global_set()
		}

	case 8:
		{
			p.SetState(718)
			p.Global_get()
		}

	case 9:
		{
			p.SetState(719)
			p.Dynamic_assignment()
		}

	case 10:
		{
			p.SetState(720)
			p.String_assignment()
		}

	case 11:
		{
			p.SetState(721)
			p.Float_assignment()
		}

	case 12:
		{
			p.SetState(722)
			p.Int_assignment()
		}

	case 13:
		{
			p.SetState(723)
			p.Assignment()
		}

	case 14:
		{
			p.SetState(724)
			p.Function_call()
		}

	case 15:
		{
			p.SetState(725)
			p.Literal_t()
		}

	case 16:
		{
			p.SetState(726)
			p.Bool_t()
		}

	case 17:
		{
			p.SetState(727)
			p.Float_t()
		}

	case 18:
		{
			p.SetState(728)
			p.Int_t()
		}

	case 19:
		{
			p.SetState(729)
			p.Nil_t()
		}

	case 20:
		{
			p.SetState(730)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RubyKParserBIT_NOT || _la == RubyKParserNOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(731)
			p.rvalue(10)
		}

	case 21:
		{
			p.SetState(732)
			p.Match(RubyKParserLEFT_RBRACKET)
		}
		{
			p.SetState(733)
			p.rvalue(0)
		}
		{
			p.SetState(734)
			p.Match(RubyKParserRIGHT_RBRACKET)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(767)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(765)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
			case 1:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_rvalue)
				p.SetState(738)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(739)
					p.Match(RubyKParserEXP)
				}
				{
					p.SetState(740)
					p.rvalue(12)
				}

			case 2:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_rvalue)
				p.SetState(741)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(742)
					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RubyKParserMUL)|(1<<RubyKParserDIV)|(1<<RubyKParserMOD))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(743)
					p.rvalue(10)
				}

			case 3:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_rvalue)
				p.SetState(744)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(745)
					_la = p.GetTokenStream().LA(1)

					if !(_la == RubyKParserPLUS || _la == RubyKParserMINUS) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(746)
					p.rvalue(9)
				}

			case 4:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_rvalue)
				p.SetState(747)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(748)
					_la = p.GetTokenStream().LA(1)

					if !(_la == RubyKParserBIT_SHL || _la == RubyKParserBIT_SHR) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(749)
					p.rvalue(8)
				}

			case 5:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_rvalue)
				p.SetState(750)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(751)
					p.Match(RubyKParserBIT_AND)
				}
				{
					p.SetState(752)
					p.rvalue(7)
				}

			case 6:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_rvalue)
				p.SetState(753)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(754)
					_la = p.GetTokenStream().LA(1)

					if !(_la == RubyKParserBIT_OR || _la == RubyKParserBIT_XOR) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(755)
					p.rvalue(6)
				}

			case 7:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_rvalue)
				p.SetState(756)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(757)
					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RubyKParserGREATER)|(1<<RubyKParserLESS)|(1<<RubyKParserLESS_EQUAL)|(1<<RubyKParserGREATER_EQUAL))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(758)
					p.rvalue(5)
				}

			case 8:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_rvalue)
				p.SetState(759)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(760)
					_la = p.GetTokenStream().LA(1)

					if !(_la == RubyKParserEQUAL || _la == RubyKParserNOT_EQUAL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(761)
					p.rvalue(4)
				}

			case 9:
				localctx = NewRvalueContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_rvalue)
				p.SetState(762)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(763)
					_la = p.GetTokenStream().LA(1)

					if !(_la == RubyKParserAND || _la == RubyKParserOR) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(764)
					p.rvalue(3)
				}

			}

		}
		p.SetState(769)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
	}

	return localctx
}

// IBreak_expressionContext is an interface to support dynamic dispatch.
type IBreak_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_expressionContext differentiates from other interfaces.
	IsBreak_expressionContext()
}

type Break_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_expressionContext() *Break_expressionContext {
	var p = new(Break_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_break_expression
	return p
}

func (*Break_expressionContext) IsBreak_expressionContext() {}

func NewBreak_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_expressionContext {
	var p = new(Break_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_break_expression

	return p
}

func (s *Break_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_expressionContext) BREAK() antlr.TerminalNode {
	return s.GetToken(RubyKParserBREAK, 0)
}

func (s *Break_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterBreak_expression(s)
	}
}

func (s *Break_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitBreak_expression(s)
	}
}

func (s *Break_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitBreak_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Break_expression() (localctx IBreak_expressionContext) {
	this := p
	_ = this

	localctx = NewBreak_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, RubyKParserRULE_break_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(770)
		p.Match(RubyKParserBREAK)
	}

	return localctx
}

// ILiteral_tContext is an interface to support dynamic dispatch.
type ILiteral_tContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteral_tContext differentiates from other interfaces.
	IsLiteral_tContext()
}

type Literal_tContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteral_tContext() *Literal_tContext {
	var p = new(Literal_tContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_literal_t
	return p
}

func (*Literal_tContext) IsLiteral_tContext() {}

func NewLiteral_tContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Literal_tContext {
	var p = new(Literal_tContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_literal_t

	return p
}

func (s *Literal_tContext) GetParser() antlr.Parser { return s.parser }

func (s *Literal_tContext) LITERAL() antlr.TerminalNode {
	return s.GetToken(RubyKParserLITERAL, 0)
}

func (s *Literal_tContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Literal_tContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Literal_tContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterLiteral_t(s)
	}
}

func (s *Literal_tContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitLiteral_t(s)
	}
}

func (s *Literal_tContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitLiteral_t(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Literal_t() (localctx ILiteral_tContext) {
	this := p
	_ = this

	localctx = NewLiteral_tContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, RubyKParserRULE_literal_t)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(772)
		p.Match(RubyKParserLITERAL)
	}

	return localctx
}

// IFloat_tContext is an interface to support dynamic dispatch.
type IFloat_tContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFloat_tContext differentiates from other interfaces.
	IsFloat_tContext()
}

type Float_tContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloat_tContext() *Float_tContext {
	var p = new(Float_tContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_float_t
	return p
}

func (*Float_tContext) IsFloat_tContext() {}

func NewFloat_tContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Float_tContext {
	var p = new(Float_tContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_float_t

	return p
}

func (s *Float_tContext) GetParser() antlr.Parser { return s.parser }

func (s *Float_tContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(RubyKParserFLOAT, 0)
}

func (s *Float_tContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Float_tContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Float_tContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterFloat_t(s)
	}
}

func (s *Float_tContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitFloat_t(s)
	}
}

func (s *Float_tContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitFloat_t(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Float_t() (localctx IFloat_tContext) {
	this := p
	_ = this

	localctx = NewFloat_tContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, RubyKParserRULE_float_t)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(774)
		p.Match(RubyKParserFLOAT)
	}

	return localctx
}

// IInt_tContext is an interface to support dynamic dispatch.
type IInt_tContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInt_tContext differentiates from other interfaces.
	IsInt_tContext()
}

type Int_tContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInt_tContext() *Int_tContext {
	var p = new(Int_tContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_int_t
	return p
}

func (*Int_tContext) IsInt_tContext() {}

func NewInt_tContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_tContext {
	var p = new(Int_tContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_int_t

	return p
}

func (s *Int_tContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_tContext) INT() antlr.TerminalNode {
	return s.GetToken(RubyKParserINT, 0)
}

func (s *Int_tContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_tContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int_tContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterInt_t(s)
	}
}

func (s *Int_tContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitInt_t(s)
	}
}

func (s *Int_tContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitInt_t(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Int_t() (localctx IInt_tContext) {
	this := p
	_ = this

	localctx = NewInt_tContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, RubyKParserRULE_int_t)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(776)
		p.Match(RubyKParserINT)
	}

	return localctx
}

// IBool_tContext is an interface to support dynamic dispatch.
type IBool_tContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBool_tContext differentiates from other interfaces.
	IsBool_tContext()
}

type Bool_tContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_tContext() *Bool_tContext {
	var p = new(Bool_tContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_bool_t
	return p
}

func (*Bool_tContext) IsBool_tContext() {}

func NewBool_tContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_tContext {
	var p = new(Bool_tContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_bool_t

	return p
}

func (s *Bool_tContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_tContext) TRUE() antlr.TerminalNode {
	return s.GetToken(RubyKParserTRUE, 0)
}

func (s *Bool_tContext) FALSE() antlr.TerminalNode {
	return s.GetToken(RubyKParserFALSE, 0)
}

func (s *Bool_tContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_tContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_tContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterBool_t(s)
	}
}

func (s *Bool_tContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitBool_t(s)
	}
}

func (s *Bool_tContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitBool_t(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Bool_t() (localctx IBool_tContext) {
	this := p
	_ = this

	localctx = NewBool_tContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, RubyKParserRULE_bool_t)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(778)
		_la = p.GetTokenStream().LA(1)

		if !(_la == RubyKParserTRUE || _la == RubyKParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INil_tContext is an interface to support dynamic dispatch.
type INil_tContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNil_tContext differentiates from other interfaces.
	IsNil_tContext()
}

type Nil_tContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNil_tContext() *Nil_tContext {
	var p = new(Nil_tContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_nil_t
	return p
}

func (*Nil_tContext) IsNil_tContext() {}

func NewNil_tContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nil_tContext {
	var p = new(Nil_tContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_nil_t

	return p
}

func (s *Nil_tContext) GetParser() antlr.Parser { return s.parser }

func (s *Nil_tContext) NIL() antlr.TerminalNode {
	return s.GetToken(RubyKParserNIL, 0)
}

func (s *Nil_tContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nil_tContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nil_tContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterNil_t(s)
	}
}

func (s *Nil_tContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitNil_t(s)
	}
}

func (s *Nil_tContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitNil_t(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Nil_t() (localctx INil_tContext) {
	this := p
	_ = this

	localctx = NewNil_tContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, RubyKParserRULE_nil_t)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		p.Match(RubyKParserNIL)
	}

	return localctx
}

// IId_Context is an interface to support dynamic dispatch.
type IId_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsId_Context differentiates from other interfaces.
	IsId_Context()
}

type Id_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_Context() *Id_Context {
	var p = new(Id_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_id_
	return p
}

func (*Id_Context) IsId_Context() {}

func NewId_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_Context {
	var p = new(Id_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_id_

	return p
}

func (s *Id_Context) GetParser() antlr.Parser { return s.parser }

func (s *Id_Context) ID() antlr.TerminalNode {
	return s.GetToken(RubyKParserID, 0)
}

func (s *Id_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterId_(s)
	}
}

func (s *Id_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitId_(s)
	}
}

func (s *Id_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitId_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Id_() (localctx IId_Context) {
	this := p
	_ = this

	localctx = NewId_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, RubyKParserRULE_id_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(782)
		p.Match(RubyKParserID)
	}

	return localctx
}

// IId_globalContext is an interface to support dynamic dispatch.
type IId_globalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsId_globalContext differentiates from other interfaces.
	IsId_globalContext()
}

type Id_globalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_globalContext() *Id_globalContext {
	var p = new(Id_globalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_id_global
	return p
}

func (*Id_globalContext) IsId_globalContext() {}

func NewId_globalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_globalContext {
	var p = new(Id_globalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_id_global

	return p
}

func (s *Id_globalContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_globalContext) ID_GLOBAL() antlr.TerminalNode {
	return s.GetToken(RubyKParserID_GLOBAL, 0)
}

func (s *Id_globalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_globalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_globalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterId_global(s)
	}
}

func (s *Id_globalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitId_global(s)
	}
}

func (s *Id_globalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitId_global(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Id_global() (localctx IId_globalContext) {
	this := p
	_ = this

	localctx = NewId_globalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, RubyKParserRULE_id_global)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.Match(RubyKParserID_GLOBAL)
	}

	return localctx
}

// IId_functionContext is an interface to support dynamic dispatch.
type IId_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsId_functionContext differentiates from other interfaces.
	IsId_functionContext()
}

type Id_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_functionContext() *Id_functionContext {
	var p = new(Id_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_id_function
	return p
}

func (*Id_functionContext) IsId_functionContext() {}

func NewId_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_functionContext {
	var p = new(Id_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_id_function

	return p
}

func (s *Id_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_functionContext) ID_FUNCTION() antlr.TerminalNode {
	return s.GetToken(RubyKParserID_FUNCTION, 0)
}

func (s *Id_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterId_function(s)
	}
}

func (s *Id_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitId_function(s)
	}
}

func (s *Id_functionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitId_function(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Id_function() (localctx IId_functionContext) {
	this := p
	_ = this

	localctx = NewId_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, RubyKParserRULE_id_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(786)
		p.Match(RubyKParserID_FUNCTION)
	}

	return localctx
}

// ITerminatorContext is an interface to support dynamic dispatch.
type ITerminatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminatorContext differentiates from other interfaces.
	IsTerminatorContext()
}

type TerminatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminatorContext() *TerminatorContext {
	var p = new(TerminatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_terminator
	return p
}

func (*TerminatorContext) IsTerminatorContext() {}

func NewTerminatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TerminatorContext {
	var p = new(TerminatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_terminator

	return p
}

func (s *TerminatorContext) GetParser() antlr.Parser { return s.parser }

func (s *TerminatorContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(RubyKParserSEMICOLON, 0)
}

func (s *TerminatorContext) Crlf() ICrlfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrlfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *TerminatorContext) Terminator() ITerminatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITerminatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITerminatorContext)
}

func (s *TerminatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TerminatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TerminatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterTerminator(s)
	}
}

func (s *TerminatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitTerminator(s)
	}
}

func (s *TerminatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitTerminator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Terminator() (localctx ITerminatorContext) {
	return p.terminator(0)
}

func (p *RubyKParser) terminator(_p int) (localctx ITerminatorContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTerminatorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITerminatorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 132
	p.EnterRecursionRule(localctx, 132, RubyKParserRULE_terminator, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(791)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RubyKParserSEMICOLON:
		{
			p.SetState(789)
			p.Match(RubyKParserSEMICOLON)
		}

	case RubyKParserCRLF:
		{
			p.SetState(790)
			p.Crlf()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(799)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(797)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
			case 1:
				localctx = NewTerminatorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_terminator)
				p.SetState(793)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(794)
					p.Match(RubyKParserSEMICOLON)
				}

			case 2:
				localctx = NewTerminatorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, RubyKParserRULE_terminator)
				p.SetState(795)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(796)
					p.Crlf()
				}

			}

		}
		p.SetState(801)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())
	}

	return localctx
}

// IElse_tokenContext is an interface to support dynamic dispatch.
type IElse_tokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElse_tokenContext differentiates from other interfaces.
	IsElse_tokenContext()
}

type Else_tokenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_tokenContext() *Else_tokenContext {
	var p = new(Else_tokenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_else_token
	return p
}

func (*Else_tokenContext) IsElse_tokenContext() {}

func NewElse_tokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_tokenContext {
	var p = new(Else_tokenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_else_token

	return p
}

func (s *Else_tokenContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_tokenContext) ELSE() antlr.TerminalNode {
	return s.GetToken(RubyKParserELSE, 0)
}

func (s *Else_tokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_tokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_tokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterElse_token(s)
	}
}

func (s *Else_tokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitElse_token(s)
	}
}

func (s *Else_tokenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitElse_token(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Else_token() (localctx IElse_tokenContext) {
	this := p
	_ = this

	localctx = NewElse_tokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, RubyKParserRULE_else_token)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(802)
		p.Match(RubyKParserELSE)
	}

	return localctx
}

// ICrlfContext is an interface to support dynamic dispatch.
type ICrlfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCrlfContext differentiates from other interfaces.
	IsCrlfContext()
}

type CrlfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrlfContext() *CrlfContext {
	var p = new(CrlfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RubyKParserRULE_crlf
	return p
}

func (*CrlfContext) IsCrlfContext() {}

func NewCrlfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrlfContext {
	var p = new(CrlfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RubyKParserRULE_crlf

	return p
}

func (s *CrlfContext) GetParser() antlr.Parser { return s.parser }

func (s *CrlfContext) CRLF() antlr.TerminalNode {
	return s.GetToken(RubyKParserCRLF, 0)
}

func (s *CrlfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrlfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrlfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.EnterCrlf(s)
	}
}

func (s *CrlfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RubyKListener); ok {
		listenerT.ExitCrlf(s)
	}
}

func (s *CrlfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case RubyKVisitor:
		return t.VisitCrlf(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *RubyKParser) Crlf() (localctx ICrlfContext) {
	this := p
	_ = this

	localctx = NewCrlfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, RubyKParserRULE_crlf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(804)
		p.Match(RubyKParserCRLF)
	}

	return localctx
}

func (p *RubyKParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 1:
		var t *Expression_listContext = nil
		if localctx != nil {
			t = localctx.(*Expression_listContext)
		}
		return p.Expression_list_Sempred(t, predIndex)

	case 12:
		var t *Function_definition_params_listContext = nil
		if localctx != nil {
			t = localctx.(*Function_definition_params_listContext)
		}
		return p.Function_definition_params_list_Sempred(t, predIndex)

	case 17:
		var t *Function_call_paramsContext = nil
		if localctx != nil {
			t = localctx.(*Function_call_paramsContext)
		}
		return p.Function_call_params_Sempred(t, predIndex)

	case 31:
		var t *For_init_listContext = nil
		if localctx != nil {
			t = localctx.(*For_init_listContext)
		}
		return p.For_init_list_Sempred(t, predIndex)

	case 34:
		var t *For_loop_listContext = nil
		if localctx != nil {
			t = localctx.(*For_loop_listContext)
		}
		return p.For_loop_list_Sempred(t, predIndex)

	case 36:
		var t *Statement_expression_listContext = nil
		if localctx != nil {
			t = localctx.(*Statement_expression_listContext)
		}
		return p.Statement_expression_list_Sempred(t, predIndex)

	case 45:
		var t *Array_definition_elementsContext = nil
		if localctx != nil {
			t = localctx.(*Array_definition_elementsContext)
		}
		return p.Array_definition_elements_Sempred(t, predIndex)

	case 47:
		var t *Dynamic_resultContext = nil
		if localctx != nil {
			t = localctx.(*Dynamic_resultContext)
		}
		return p.Dynamic_result_Sempred(t, predIndex)

	case 49:
		var t *Int_resultContext = nil
		if localctx != nil {
			t = localctx.(*Int_resultContext)
		}
		return p.Int_result_Sempred(t, predIndex)

	case 50:
		var t *Float_resultContext = nil
		if localctx != nil {
			t = localctx.(*Float_resultContext)
		}
		return p.Float_result_Sempred(t, predIndex)

	case 51:
		var t *String_resultContext = nil
		if localctx != nil {
			t = localctx.(*String_resultContext)
		}
		return p.String_result_Sempred(t, predIndex)

	case 56:
		var t *RvalueContext = nil
		if localctx != nil {
			t = localctx.(*RvalueContext)
		}
		return p.Rvalue_Sempred(t, predIndex)

	case 66:
		var t *TerminatorContext = nil
		if localctx != nil {
			t = localctx.(*TerminatorContext)
		}
		return p.Terminator_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *RubyKParser) Expression_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *RubyKParser) Function_definition_params_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *RubyKParser) Function_call_params_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *RubyKParser) For_init_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *RubyKParser) For_loop_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *RubyKParser) Statement_expression_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *RubyKParser) Array_definition_elements_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *RubyKParser) Dynamic_result_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *RubyKParser) Int_result_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *RubyKParser) Float_result_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 18:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *RubyKParser) String_result_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 22:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *RubyKParser) Rvalue_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 24:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 25:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 26:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 27:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 28:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 29:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 30:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 31:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 32:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *RubyKParser) Terminator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 33:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 34:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
